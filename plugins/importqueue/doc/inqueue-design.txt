Design of the AIRT Import Queue
===============================================================================
$Id$

The AIRT Import Queue is a mechanism to send machine-generated notices to
AIRT. The notices are presented to AIRT via one of several intake mechanisms
(SMTP mailbox, HTTP(S) POST drop, command line, ...), filtered down to one
generic, robust XML format using the correct input filter, and stored in the
AIRT Import Queue. This queue can be reviewed by AIRT users and the notices
can be either rejected or accepted. Accepted notices are mapped to a normal
AIRT "New Incident" form, ready to be added to the AIRT system with a single
button click.


Intakers
--------
The intaker is a command which should be used to interface from outside AIRT
to the import queue. All import mechanisms eventually draw on this command.

  airt_import [--verbose] [--noqueue] [--filter filter] importfile

Returns 0 on successful import, 1 when rejected. If rejected, stderr will
contain a reasonable message why. The intaker is totally silent on stdout
when everything goes OK (return code 0), unless --verbose is given. The
--noqueue switch inhibits actual processing of the import file, but runs all
relevant sanity checks.

The airt_import command itself has been implemented in PHP (using the
/usr/bin/php command line interpreter).

Main task of the airt_import command is to roughly validate the input (is
there any), find out the correct input filter (use the command line switch
if available, select an inert default filter otherwise), pass the input
through the correct filter, and deliver the resulting XML stream to the
PostgreSQL database. Any problem during the process will be reported back to
the caller using return code 1 and a proper string output on stdout, as
described above.

Some knowledge of the AIRT installation is required for import operation.
The program must therefore read the <AIRT>/etc/airt.cfg configuration file,
and use the exact same parameters as the AIRT core. The same Autoconf
mechanism as for the core must be used to prepare the import program for
this.

The SMTP gateway is based on maildrop or procmail, and essentially call
"import" with the mail body and the proper filter selector.


Input filters
-------------
Filters are used by the airt_import CLI processor and convert incoming wild
file formats to one single standard XML format. We implemented a null filter
as default, i.e., leaving out the --filter option means "no filtering," but
is implemented as a call to a filter function which does not do anything.
This makes the design more straightforward.

All filters are implemented as straightforward PHP functions, and the
import CLI processor includes all available functions at startup. Filter
functions are placed under the importqueue directory:
  <AIRT>/lib/importqueue/filter_<name>.plib
The airt_import program scans this directory at startup and includes all
files that match /filter_.+\.plib/. For each included file, the airt_import
program looks for a defined function "filter_<name>". If defined, it is
added to a list of available filter functions. If not defined, a warning
will appear on stderr.

Filter functions have a standard API:
  $returnCode = filter_<name>($inputString, $outputString, $verbosity=FALSE);
The $returnCode is by convention 0 for successful completion, and non-zero
for problems. If successful, the $outputString variable will contain the
resulting XML (previous content will be destroyed, pass-by-reference). If
unsuccessful, $outputString contains the reason why. $verbosity is an
optional parameter, which causes the function to produce textual messages on
stdout if TRUE.

Filters are not designed to be chained. We provide all-in-one filter
functions, even if they may share some code. How this code is shared is left
to the programmer of the filter functions. She may decide to use shared
subfunctions, but this knowledge is not passed on beyond the filter function
API. In an extreme case, the various filter_<name>.plib files only contain
wrapper functions and all require_once the same huge library file.

The reference implementation is a plain passthrough filter, which assumes to
get XML input. This will be called filter_none.plib and also function as the
default filter for the airt_import program.


Import Queue
------------
The import queue has two sides: a metadata part, which administers a few
details such as time stamp and sender, and a data part where the incoming
XML is stored without any preprocessing. Both parts are implemented in the
same PostgreSQL table, but need to be conceptually separated. "We don't
touch the XML."

CREATE TABLE import_queue (
  id        integer,
  created   timestamp    not null,
  status    varchar(16)  not null default 'open',
  sender    varchar(50)  not null,
  type      varchar(50)  not null,
  summary   varchar(100) not null,
  content   text         not null,
  primary key (id)
)

This table does not depend on any foreign keys, as the incoming data has
not yet been semantically validated (that is the task of the AIRT core,
later on, when creating a new incident). All fields in this table are
mandatory and if any element misses, the queue entry is rejected.

"Id", "created" and "status" are administrative information for the queue
manager, and do not come from the import file. They are discussed below.

"Sender" is the entity (not necessarily a machine) sending the import
request. Typical names here could be "SURFnet", "Yogibear", etc.

"Type" is the broad category of the request, typically chosen from a small
set of common types that are shared by the AIRT community. However, there is
no type validation, the field is treated as a pure string and only used for
ordering and display.

"Summary" is a free text string which allows for a brief statement of what
the request is about. Although the maximum length is 100 characters, the
interface may truncate this string for display space reasons, so the string
should be as brief as possible and contain the important stuff at the
beginning.

Nearly all fields are provided by the import file. The actual import queue
mechanism only adds the unique queue ID, the time stamp, and the status
('open', 'rejected', 'accepted'). The rest is extracted out of the XML. It
is possible that the input filter adds some elements by means of hard
coding, e.g., a specific filter for the Yogibear honeypot log reports might
be hard-coded to set the sender field to "Yogibear" and the type field to
"Honeypot log". But the intention is to write generic filters, so it is
preferable to have these data in the actual input file (not necessarily XML
yet).


Import Queue Manager
--------------------
The Queue Manager or Queue Viewer is a plain PHP/HTML implementation of a
viewer and limited commander for the Queue. It provides a simple overview of
all open queue entries, and offers the operator direct selections to accept
the entry, reject it, or view its detailed contents.

We expect the queue length to remain small, about 20 open entries at most.
This means that we do not need to implement elaborate sorting and selection
options, at least not at this moment. The available metadata fields should
be sufficient for the operator to do a quick scan, and when in doubt (s)he
can look directly at the XML file for more information.

Entries which have been accepted or rejected are marked as such, and
disappear from the standard queue viewer. They can be recalled with a
selection option. Retention of accepted or rejected entries is left to the
operator policy, AIRT does not yet offer a built-in mechanism to purge
expired entries (operational experience has to be gathered to decide what
kind of policy needs to be implemented). However, the nature of the import
queue offers plenty of possibilities to manually or mechanically purge
entries without disturbing any queue mechanism.


Web Service
-----------
[needs to be written]


Import queue XML input
----------------------
All filters are expected to deliver one standard XML format, described as an
XML schema in .../source/doc/airt.xsd . An example is:

<airt:airt xmlns:airt="http://infolab.uvt.nl/airt">
  <airt:importqueue>
    <airt:queuedata ref="#1">
      <airt:status>open</airt:status>
      <airt:sender>SURFNET-NL</airt:sender>
      <airt:type>Cymru</airt:type>
      <airt:summary>Phatbot found</airt:summary>
    </airt:queuedata>
  </airt:importqueue>
  <airt:incident id="1">
    <airt:ticketInformation>
      <airt:prefix>Cymru</airt:prefix>
    </airt:ticketInformation>
    <airt:technicalInformation>
      <airt:ip>137.56.244.8</airt:ip>
      <airt:incident_time>2005-07-13 13:17:01</airt:incident_time>
      <airt:logging>1103 | 137.56.244.8 | 2005-07-13 13:17:01 | Phatbot | SURFNET-NL</airt:logging>
   </airt:technicalInformation>
  </airt:incident>
</airt:airt>

The <airt:importqueue> and <airt:incident> chunks may repeat, and the
attributes of both are matched to pair the chunks.


[EOF]
