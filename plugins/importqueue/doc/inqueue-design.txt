Design of the AIRT Import Queue
===============================================================================
$Id$

The AIRT Import Queue is a mechanism to send machine-generated notices to
AIRT. The notices are presented to AIRT via one of several intake mechanisms
(SMTP mailbox, HTTP(S) POST drop, command line, ...), filtered down to one
generic, robust XML format using the correct input filter, and stored in the
AIRT Import Queue. This queue can be reviewed by AIRT users and the notices
can be either rejected or accepted. Accepted notices are mapped to a normal
AIRT "New Incident" form, ready to be added to the AIRT system with a single
button click.


Intakers
--------
The intaker is a command which should be used to interface from outside AIRT
to the import queue. All import mechanisms eventually draw on this command.

  <AIRT>/plugins/importqueue/bin/import [--verbose] [--noqueue] \
        [--filter filter] < importfile

Returns 0 on successful import, 1 when rejected. If rejected, stderr will
contain a reasonable message why. The intaker is totally silent on stdout
when everything goes OK (return code 0), unless --verbose is given. The
--noqueue switch inhibits actual processing of the import file, but runs all
sanity checks.

"import" currently is also used for an X11 support program, see import(1).
Since the AIRT importer will not often be called as a plain command which
relies on $PATH to be found, this is not considered a problem.

The import command itself has been implemented in PHP (using the
/usr/bin/php command line interpreter).

Main task of the import command is to roughly validate the input (is there
any), find out the correct input filter (use the command line switch if
available, select an inert default filter otherwise), pass the input through
the correct filter, and deliver the resulting XML stream to the PostgreSQL
database. Any problem during the process will be reported back to the caller
using return code 1 and a proper string output on stdout, as described
above.

Some knowledge of the AIRT installation is required for import operation.
The program should therefore read the <AIRT>/etc/airt.cfg configuration
file, and use the exact same parameters as the AIRT core. The same Autoconf
mechanism as for the core should be used to prepare the import program for
this.

The SMTP gateway will be based on maildrop or procmail, and essentially call
"import" with the mail body and the proper filter selector.


Input filters
-------------
Filters are used by the import CLI processor and convert incoming wild file
formats to one single standard XML format. We implement a null filter as
default, i.e., leaving out the --filter option means "no filtering," but
is implemented as a call to a filter function which does not do anything.
This makes the design more straightforward.

All filters are implemented as straightforward PHP functions, and the
import CLI processor includes all available functions at startup. Filter
functions are placed under the importqueue directory:
  <AIRT>/plugins/importqueue/lib/filter_<name>.plib
The import program scans this directory at startup and includes all files
that match /filter_.+\.plib/. For each included file, the import program
looks for a defined function "filter_<name>". If defined, it is added to a
list of available filter functions. If not defined, a warning will appear on
stderr.

Filter functions have a standard API:
  $returnCode = filter_<name>($inputString, $outputString, $verbosity=0);
The $returnCode is by convention 0 for successful completion, and non-zero
for problems. If successful, the $outputString variable will contain the
resulting XML (previous content will be destroyed, pass-by-reference). If
unsuccessful, $outputString contains the reason why. $verbosity is an
optional parameter, which causes the function to produce textual messages on
stdout if greater than zero. Convention is to have two levels: informational
(1) and debug (2). The --verbose switch to the import command causes the
informational (1) value; debug (2) is for development only.

Filters are not designed to be chained. We provide all-in-one filter
functions, even if they may share some code. How this code is shared is left
to the programmer of the filter functions. She may decide to use shared
subfunctions, but this knowledge is not passed on beyond the filter function
API. In an extreme case, the various filter_<name>.plib files only contain
wrapper functions and all require_once the same huge library file.

First implementation is a plain passthrough filter, which assumes to get XML
input. This will be called filter_none.plib and also function as the default
filter for the import program.


Import Queue
------------
The import queue has two sides: a metadata part, which administers a few
details such as time stamp and sender, and a data part where the incoming
XML is stored without any preprocessing.

The metadata part can be implemented as a straightforward PostgreSQL table:

CREATE TABLE import_queue (
  id        integer,
  created   timestamp    not null,
  status    varchar(16)  not null default 'open',
  sender    varchar(50)  not null,
  type      varchar(50)  not null,
  summary   varchar(100) not null,
  primary key (id)
)

This table should not depend on any foreign keys, as the incoming data has
not yet been semantically validated (that is the task of the AIRT core,
later on, when creating a new incident). All fields in this table are
mandatory and if a metadata element misses, the queue entry is rejected.

"Id", "created" and "status" are administrative information for the queue
manager, and do not come from the import file. They are discussed below.

"Sender" is the entity (not necessarily a machine) sending the import
request. Typical names here could be "SURFnet", "Yogibear", etc.

"Type" is the broad category of the request, typically chosen from a small
set of common types that are shared by the AIRT community. However, there is
no type validation, the field is treated as a pure string and only used for
ordering and display.

"Summary" is a free text string which allows for a brief statement of what
the request is about. Although the maximum length is 100 characters, the
interface may truncate this string for display space reasons, so the string
should be as brief as possible and contain the important stuff at the
beginning.

Nearly all fields are provided by the import file. The actual import queue
mechanism only adds the unique queue ID, the time stamp, and the status
('open', 'rejected', 'accepted'). The rest is extracted out of the XML. It
is possible that the input filter adds some elements by means of hard
coding, e.g., a specific filter for the Yogibear honeypot log reports might
be hard-coded to set the sender field to "Yogibear" and the type field to
"Honeypot log". But the intention is to write generic filters, so it is
preferable to have these data in the actual input file (not necessarily XML
yet).

The data part could be implemented in PostgreSQL as well, as the database
engine can accomodate fields of up to a Gigabyte in length. A tighter limit
might be imposed by the SQL parser buffer. Experience taught us that it is
nearly impossible to manually test or review tables with this type of long
text entries though, reasons why we prefer to keep the flat XML in the file
system and not put it in the SQL database. The file naming policy is simple:
  STATEDIR."/importqueue/<id>.xml"
where the actual directory typically will end up in /var/lib/airt.


Import Queue Manager
--------------------
The Queue Manager or Queue Viewer is a plain PHP/HTML implementation of a
viewer and limited commander for the Queue. It provides a simple overview of
all open queue entries, and offers the operator direct selections to accept
the entry, reject it, or view its detailed contents.

We expect the queue length to remain small, about 20 open entries at most.
This means that we do not need to implement elaborate sorting and selection
options, at least not at this moment. The available metadata fields should
be sufficient for the operator to do a quick scan, and when in doubt (s)he
can look directly at the XML file for more information.

Entries which have been accepted or rejected are marked as such, and
disappear from the standard queue viewer. They can be recalled with a
selection option. Retention of accepted or rejected entries is left to the
operator policy, AIRT does not yet offer a built-in mechanism to purge
expired entries (operational experience has to be gathered to decide what
kind of policy needs to be implemented). However, the nature of the import
queue offers plenty of possibilities to manually or mechanically purge
entries without disturbing any queue mechanism.


Form Injector
-------------
Bit of code to extract required and optional data from the standard XML and
present this to the already existing Incident Form. We need only a few items
here, derived from the New Incident form:

Incident type  (installation-dependent)
Incident state (installation-dependent)
Incident status (likely defaulting to 'open')
Affected IP address(es) with corresponding constituency/cies
Affected user(s) as E-mail addresses

The two check boxes (create user and prepare mail) need to be examined in
more detail.

File to inject to (with POST or GET) likely will be incident.php, the GET
option might need to be added.

With so many installation-dependent things, this starts smelling of
extensive pre-installation configuration. We might be better off putting
some default type and state entries in the AIRT bootstrap, so that the
standard filters can successfully add these fields. On the other hand, we
might simply select the operator's default choice here, or inject our choice
which if not available falls back to operator's default, or assume that any
filter will be customised anyway. This needs some discussion and/or policy
specification.


Web Service
-----------
[needs to be written]


Import queue XML input
----------------------
All filters are expected to deliver one standard XML format, described as an
XML schema in .../source/doc/airt.xsd . An example is:

<airt:airt xmlns:airt="http://infolab.uvt.nl/airt">
  <airt:importqueue>
    <airt:queuedata ref="#1">
      <airt:status>open</airt:status>
      <airt:sender>SURFNET-NL</airt:sender>
      <airt:type>Cymru</airt:type>
      <airt:summary>Phatbot found</airt:summary>
    </airt:queuedata>
  </airt:importqueue>
  <airt:incident id="1">
    <airt:ticketInformation>
      <airt:prefix>Cymru</airt:prefix>
    </airt:ticketInformation>
    <airt:technicalInformation>
      <airt:ip>137.56.244.8</airt:ip>
      <airt:incident_time>2005-07-13 13:17:01</airt:incident_time>
      <airt:logging>1103 | 137.56.244.8 | 2005-07-13 13:17:01 | Phatbot | SURFNET-NL</airt:logging>
   </airt:technicalInformation>
  </airt:incident>
</airt:airt>

The <airt:importqueue> and <airt:incident> chunks may repeat, and the
attributes of both are matched to pair the chunks.


[EOF]
