Design of the AIRT Import Queue
===============================================================================
$Id$

The AIRT Import Queue is a mechanism to send machine-generated notices to
AIRT. The notices are presented to AIRT via one of several intake mechanisms
(SMTP mailbox, HTTP(S) POST drop, command line, ...), filtered down to one
generic, robust XML format using the correct input filter, and stored in the
AIRT Import Queue. This queue can be reviewed by AIRT users and the notices
can be either rejected or accepted. Accepted notices are mapped to a normal
AIRT "New Incident" form, ready to be added to the AIRT system with a single
button click.


Intakers
--------
At first we implement the command line intaker. This one likely will be the
work horse of the SMTP and HTTP(S) intakers anyway.

Proposed file name and typical command line:
  <AIRT>/bin/import [--verbose] [--noqueue] [--filter filter] < importfile

Returns 0 on successful import, 1 when rejected. If rejected, stderr will
contain a reasonable message why. The intaker is totally silent on stdout
when everything goes OK (return code 0), unless --verbose is given. The
--noqueue switch inhibits actual processing of the import file, but runs all
sanity checks.

"import" currently is also used for an X11 support program, see import(1).
airt-import sounds like a good alternative. It all depends on path settings
and whether we want to use the $PATH at all anyway.

The PHP external execution command proc_open() allows for explicit
connection to the stdin, stdout, and stderr file descriptors, so this should
not be any problem to implement from the PHP caller's side (assuming that
the HTTP(S) dropper will be implemented in PHP and should call the CLI
command "import").

The import command itself likely will be implemented in PHP (using the
/usr/bin/php command line interpreter). We need to see whether this use of
PHP would conflict with any standard installation; this is not very likely.
Doing it in Perl, Bash or Tcl might be slightly easier on the installer, but
has no real advantages.

Main task of the import command is to roughly validate the input (is there
any), find out the correct input filter (use the command line switch if
available, do an educated guess otherwise using magic cookies), pass the
input through the correct filter using a piped command, and deliver the
resulting XML stream to the PostgreSQL database. Any problem during the
process will be reported back to the caller using return code 1 and a proper
string output on stdout, as described above.

Some knowledge of the AIRT installation is required for import operation.
The program should therefore read the <AIRT>/etc/airt.cfg configuration
file, and use the exact same parameters as the AIRT core. The same Autoconf
mechanism as for the core should be used to prepare the import program for
this.

The SMTP gateway will be based on maildrop or procmail, and essentially call
"import" with the mail body.


Input filters
-------------
First implementation is a plain passthrough filter, which assumes to get XML
input. As the input filters have no need to know anything but pipe in, pipe
out, the proposal is to implement them as CLI processes using PHP with as
little dependency on anything as possible. We might want to collect all
filters in a subdirectory, but at this moment that seems unnecessary.

An alternative that needs to be discussed is to implement the filters as PHP
functions, and have them included by the import CLI processor.

Proposed file name and typical command line:
  <AIRT>/bin/cymru < input > output.xml

All filters return 0 on success and 1 on failure, with the reason for the
failure dumped to stderr. Their naming allows the intaker to be called as:
  <AIRT>/bin/import --filter cymru < sourcefile
The import program should be able to find the filters via the AIRT
configuration settings.

Another option to be discussed is the possibility to chain filters,
typically a format filter and a type filter:
  <AIRT>/bin/import --filter smtp --filter cymru
This way we can implement a generic filter from SMTP or HTTP(S) format to
something more generic, followed by the actual data parsing to XML.


Import Queue
------------
The import queue has two sides: a metadata part, which administers a few
details such as time stamp and sender, and a data part where the incoming
XML is stored without any preprocessing.

The metadata part can be implemented as a straightforward PostgreSQL table:

CREATE TABLE import_queue (
  id        integer,
  created   timestamp    not null,
  status    varchar(16)  not null default 'open',
  sender    varchar(50)  not null,
  type      varchar(50)  not null,
  summary   varchar(100) not null,
  primary key (id)
)

This table should not depend on any foreign keys, as the incoming data has
not yet been semantically validated (that is the task of the AIRT core,
later on, when creating a new incident). All fields in this table are
mandatory and if a metadata element misses, the queue entry is rejected.

"Id", "created" and "status" are administrative information for the queue
manager, and do not come from the import file. They are discussed below.

"Sender" is the entity (not necessarily a machine) sending the import
request. Typical names here could be "SURFnet", "Yogibear", etc.

"Type" is the broad category of the request, typically chosen from a small
set of common types that are shared by the AIRT community. However, there is
no type validation, the field is treated as a pure string and only used for
ordering and display.

"Summary" is a free text string which allows for a brief statement of what
the request is about. Although the maximum length is 100 characters, the
interface may truncate this string for display space reasons, so the string
should be as brief as possible and contain the important stuff at the
beginning.

Nearly all fields are provided by the import file. The actual import queue
mechanism only adds the unique queue ID, the time stamp, and the status
('open', 'rejected', 'accepted'). The rest is extracted out of the XML. It
is possible that the input filter adds some elements by means of hard
coding, e.g., a specific filter for the Yogibear honeypot log reports might
be hard-coded to set the sender field to "Yogibear" and the type field to
"Honeypot log". But the intention is to write generic filters, so it is
preferable to have these data in the actual input file (not necessarily XML
yet).

The data part could be implemented in PostgreSQL as well, as the database
engine can accomodate fields of up to a Gigabyte in length. A tighter limit
might be imposed by the SQL parser buffer. Experience taught us that it is
nearly impossible to manually test or review tables with this type of long
text entries though, reasons why we prefer to keep the flat XML in the file
system and not put it in the SQL database. The file naming policy is simple:
  <AIRT>/var/import/<ID>.xml
where the actual directory typically will end up in /var/lib/airt/import.


Import Queue Manager
--------------------
The Queue Manager or Queue Viewer is a plain PHP/HTML implementation of a
viewer and limited commander for the Queue. It provides a simple overview of
all open queue entries, and offers the operator direct selections to accept
the entry, reject it, or view its detailed contents.

We expect the queue length to remain small, about 20 open entries at most.
This means that we do not need to implement elaborate sorting and selection
options, at least not at this moment. The available metadata fields should
be sufficient for the operator to do a quick scan, and when in doubt (s)he
can look directly at the XML file for more information.

Entries which have been accepted or rejected are marked as such, and
disappear from the standard queue viewer. They can be recalled with a
selection option. Retention of accepted or rejected entries is left to the
operator policy, AIRT does not yet offer a built-in mechanism to purge
expired entries (operational experience has to be gathered to decide what
kind of policy needs to be implemented). However, the nature of the import
queue offers plenty of possibilities to manually or mechanically purge
entries without disturbing any queue mechanism.


Form Injector
-------------
Bit of code to extract required and optional data from the standard XML and
present this to the already existing Incident Form. We need only a few items
here, derived from the New Incident form:

Incident type  (installation-dependent)
Incident state (installation-dependent)
Incident status (likely defaulting to 'open')
Affected IP address(es) with corresponding constituency/cies
Affected user(s) as E-mail addresses

The two check boxes (create user and prepare mail) need to be examined in
more detail.

File to inject to (with POST or GET) likely will be incident.php, the GET
option might need to be added.

With so many installation-dependent things, this starts smelling of
extensive pre-installation configuration. We might be better off putting
some default type and state entries in the AIRT bootstrap, so that the
standard filters can successfully add these fields. On the other hand, we
might simply select the operator's default choice here, or inject our choice
which if not available falls back to operator's default, or assume that any
filter will be customised anyway. This needs some discussion and/or policy
specification.

[EOF]
