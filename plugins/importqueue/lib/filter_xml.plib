<?php
/* vim: syntax=php tabstop=3 shiftwidth=3
 *
 * AIRT: APPLICATION FOR INCIDENT RESPONSE TEAMS
 * Copyright (C) 2005   Tilburg University, The Netherlands

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * filter_surfnet.plib -- filter function for surfnet reports
 * 
 * $Id$
 */

define('CUTOFF', 5);
/* Import queue filter function for Honeyd reports.
 * Parameters:
 *    input     = The SURFnet report email, headers and everything.
 *    output    = The string variable to write the XML output to.
 *    verbosity = Optionally, boolean; TRUE = verbose output to STDOUT.
 * Returns:
 *    0 on success (can not yet fail).
 */
function filter_xml($input, &$output, $verbosity=FALSE) {
   /* fetch XML from message */
   $matches=array();
   preg_match('/(<airt>.*<\/airt>)/s', $input, $matches);
   if (sizeof($matches) == 0) {
      print "Unable to find xml\n";
      return 0;
   }

   /* build DOM tree from input*/
   $error = array();
   $dom = domxml_open_mem($matches[1], DOMXML_LOAD_PARSING, $error);

   /* fetch all source ips and count them*/
   $srcips=array();
   $xpath = $dom->xpath_new_context();
   $obj = $xpath->xpath_eval('//contact/source/ip');
   $nodeset=$obj->nodeset;
   foreach ($nodeset as $node) {
      if (array_key_exists($node->get_content(), $srcips)) {
         $srcips[$node->get_content()] += 1;
      } else {
         $srcips[$node->get_content()] = 1;
      }
   }

   /* discard everything with less that $CUTOFF hits */
   foreach ($srcips as $ip=>$count) {
      if ($count < CUTOFF) {
         unset($srcips[$ip]);
      }
   }

   /* Try to find the sender of the message */
   if (preg_match('/^From: (.+)/m', $input, $matches)==1) {
      $sender = htmlSpecialChars($matches[1]);
   } else {
      $sender = 'unknown';
   }

   /* create output DOM tree */
   $out = domxml_new_doc('1.0');
   $airt = $out->add_root('airt');

   $id = 1;
   foreach ($srcips as $ip=>$count) {
      /* create queue data element and its children*/
      $queuedata  = $out->create_element('queuedata');
      $status_el  = $out->create_element('status');
      $sender_el  = $out->create_element('sender');
      $type_el    = $out->create_element('type');
      $summary_el = $out->create_element('summary');

      $hostname = gethostbyaddr($ip);
      $queuedata->set_attribute('ref', "#$id");
      $status_el->set_content('open');
      $sender_el->set_content($sender);
      $type_el->set_content('honeyd logging');
      $summary_el->set_content("Honeyd logging $hostname [$ip] ");

      $queuedata->append_child($status_el);
      $queuedata->append_child($sender_el);
      $queuedata->append_child($type_el);
      $queuedata->append_child($summary_el);

      /* create incident element and its children */
      $incident_el = $out->create_element('incident');
      $techinfo_el = $out->create_element('technicalInformation');
      $ip_el       = $out->create_element('ip');
      $host_el     = $out->create_element('hostname');
      $num_el      = $out->create_element('number_attempts');
      $logging_el  = $out->create_element('logging');

      $incident_el->set_attribute('id', $id++);
      $ip_el->set_content($ip);
      $host_el->set_content($hostname);
      $num_el->set_content($count);

      /* fetch corresponding nodes from import DOM tree*/
      $xpath = $dom->xpath_new_context();
      $obj = $xpath->xpath_eval_expression("contact[source[ip='$ip']]");
      $logging = '';
      foreach ($obj->nodeset as $contact) {
         $protos = $contact->get_elements_by_tagname('protocol');
         $times = $contact->get_elements_by_tagname('time');
         $sources = $contact->get_elements_by_tagname('source');
         $targets = $contact->get_elements_by_tagname('target');

         $srcips = $sources[0]->get_elements_by_tagname('ip');
         $srcports = $sources[0]->get_elements_by_tagname('port');
         $dstips = $targets[0]->get_elements_by_tagname('ip');
         $dstports = $targets[0]->get_elements_by_tagname('port');

         $logging .= sprintf("%s (%s): %s: From %s:%s to %s:%s\n",
         $times[0]->get_content(), $times[0]->get_attribute('zone'),
         $protos[0]->get_content(), $srcips[0]->get_content(),
         $srcports[0]->get_content(), $dstips[0]->get_content(),
         $dstports[0]->get_content());
      }
      $logging_el->set_content($logging);

      $techinfo_el->append_child($ip_el);
      $techinfo_el->append_child($host_el);
      $techinfo_el->append_child($num_el);
      $techinfo_el->append_child($logging_el);
      $incident_el->append_child($techinfo_el);

      /* create airt node */
      $airt->append_child($queuedata);
      $airt->append_child($incident_el);
   }

   $output = $out->dump_mem(true);
   if ($verbosity == true) {
      print $output;
   }
   return 0;
}
?>
