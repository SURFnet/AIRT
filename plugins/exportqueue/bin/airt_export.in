#!/usr/bin/php
<?php
/* vim: syntax=php tabstop=3 shiftwidth=3
 *
 * AIRT: APPLICATION FOR INCIDENT RESPONSE TEAMS
 * Copyright (C) 2005   Tilburg University, The Netherlands

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * airt_export -- spawn off external tasks from the AIRT Export Queue.
 * 
 * $Id$
 */

define('AIRT_VERSION','@VERSION@');

// Pick up standard AIRT config and required library (which pulls in the
// other required libraries).
require_once '@ETCPATH@/airt.cfg';
require_once ETCDIR.'/exportqueue.cfg';
require_once LIBDIR.'/exportqueue/exportqueue.plib';

// Set up all default command line options.
// Options are either Boolean (--option) or scalar (--option=value).
$OPTIONS = array();
$OPTIONS['--help']    = false;
$OPTIONS['--noqueue'] = false;
$OPTIONS['--verbose'] = false;

// Run over command line arguments.
array_shift($argv);               // get rid of argument 0, the command itself.
foreach ($argv as $param) {
   if (substr($param,0,2)=='--') {
      // Option parameter.
      @list($option,$value) = split('=',$param);
      if (isset($OPTIONS[$option])) {
         // Known option, get new value of the correct type.
         if (is_bool($OPTIONS[$option])) {
            $OPTIONS[$option] = true;
         } else {
            $OPTIONS[$option] = $value;
         }
      } else {
         // Unknown option, quit.
         fwrite(STDERR, t('ERROR: Unknown option "%s".',
                          array('%s'=>$option)).
                        "\n");
         exit(1);
      }
   }
   // File parameters are not used, at least not yet. See importqueue for a
   // good example on how to handle them.
}// foreach parameter

// Retrieve all wrappers installed in LIBDIR. We need this list for --help,
// so we build it even when no actual task calling might take place.
// Due to the possibility of double inclusion of the same directory, we
// suppress second or third occurrences of the same wrapper.
$WRAPPERS = array();
foreach ($AIRT_EXPORTWRAPPER_DIRS as $dir) {
   $libdir = opendir($dir);
   while ($file = readdir($libdir)) {
      $wrapper_name = basename($file);
      if (substr($wrapper_name,0,8)=='wrapper_') {
         // Found a wrapper file. Check whether it is executable.
         if (!is_executable($dir.'/'.$wrapper_name)) {
            // Bad wrapper, complain but do not quit.
            fwrite(STDERR, t('WARNING: wrapper "%s" not executable.',
                             array('%s'=>$wrapper_name)).
                           "\n");
         } else {
            // Ok, register the wrapper if we don't have it yet.
            if (array_search(substr($wrapper_name,8),$WRAPPERS)===FALSE) {
              $WRAPPERS[] = substr($wrapper_name,8);
            }
         }
      }
   }// for each file name
   closedir($libdir);
}

// Help requested?
if ($OPTIONS['--help']) {
   printUsage();
   exit(0);
}

// ACTUAL ACTIONS HERE. Should be completed in about 5 seconds or less.

# Connect to database.

# Purge all tasks that have an "ended" time stamp 24+ hours ago (setting).

# For each task that has previously been spawned, do:
#   Find out the output file.
#   If file available, read it and save as "result".
#   Fill in "ended" time stamp (ctime of file or current time?).

# For each task to spawn, do:
#   Find out wrapper to call.
#   Find out output file to point wrapper at.
#   Find out parameters for the wrapper.
#   Fill in "started" time stamp.
#   Fork and exec wrapper.
$task = '/usr/local/share/airt/lib/exportqueue/wrapper_none';
msg("Spawning background task '$task'...");
$error = spawnTask($task);
if ($error!='') {
   // Oops. Signal the problem, but continue processing, as we are in a
   // loop.
   fwrite(STDERR, t('ERROR: ').$error."\n");
}

# Disconnect from database.

# Clean up and exit.

// Successful completion.
msg('airt_export done.');
return 0;

?>
