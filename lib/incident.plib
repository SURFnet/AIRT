<?php
/* vim: syntax=php shiftwidth=3 tabstop=3
 * AIRT: Application for Incident Response Teams
 * Copyright (C) 2004,2005   Kees Leune <kees@uvt.nl>

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * incident.plib - Incident management application logic
 *
 * $Id$
 */
require_once LIBDIR.'/database.plib';
require_once LIBDIR.'/search.plib';
require_once LIBDIR.'/constituency.plib';
require_once LIBDIR.'/history.plib';
require_once LIBDIR.'/airt.plib';

/* Return an associative array with incident states.
 * Input: optionally, an array with extra incident states that are not from
 * the database. Typically, "Please select a state"-like inert selections.
 * Array format: array[extra_id]=extra_label. The extra states are prefixed
 * before the states from the database.
 * Output: array[id]=label.
 */
function getIncidentStates($extras=array()) {
   $res = db_query('SELECT  id, label FROM incident_states ORDER BY id')
   or die('Unable to connect to database.');

   $states=$extras;
   while ($row = db_fetch_next($res)) {
      $states[$row["id"]]=$row["label"];
   }
   return $states;
}

/* Return the current incident state ID system default. If there is no
 * explicit default set, return an empty string. */
function getIncidentStateDefault() {
   $res = db_query('SELECT id FROM incident_states WHERE isdefault')
   or die('Unable to execute query.');

   if (db_num_rows($res)==1) {
      // Exactly one row == exactly one default, perfect.
      $row = db_fetch_next($res);
      $default = $row['id'];
   } else {
      // Unsure.
      $default = '';
   }
   return $default;
}

/* Return an HTML SELECT box containing valid choices for incident states.
 * Input: name = The HTML name of the selection box.
 *        default = Optionally, the ID of the default selection. If not
 *                  given, the database default state is used as selection
 *                  default.
 *        extras = Optionally, an array [id]=>label with extra states that
 *                 do not come from the database, and that are prefixed
 *                 before the database states (typically "Select State").
 * Output: HTML string with full <select> block.
 */
function getIncidentStateSelection($name, $default='', $extras=array()) {
   $output = sprintf("<select name=\"%s\">\n", htmlentities($name));
   $states = getIncidentStates($extras);
   if ($default=='') {
      $default = getIncidentStateDefault();
   }
   foreach ($states as $i=>$l) {
      $output .= sprintf("<option value=\"%s\" %s>%s</option>\n", htmlentities($i), ($i == $default) ? "SELECTED" : "", htmlentities($l));
   }
   $output .= "</select>";
   return $output;
}

/* Return an associative array with incident statuses.
 * Input: optionally, an array with extra incident statuses that are not from
 * the database. Typically, "Please select a status"-like inert selections.
 * Array format: array[extra_id]=extra_label. The extra statuses are prefixed
 * before the statuses from the database.
 * Output: array[id]=label.
 */
function getIncidentStatus($extras=array()) {
   $res = db_query('SELECT id, label FROM incident_status ORDER BY id')
   or die("Unable to connect to database.");

   $statuses=$extras;
   while ($row = db_fetch_next($res)) {
      $statuses[$row["id"]]=$row["label"];
   }
   return $statuses;
}

/* Return the current incident status ID system default. If there is no
 * explicit default set, return an empty string. */
function getIncidentStatusDefault() {
   $res = db_query('SELECT id FROM incident_status WHERE isdefault')
   or die('Unable to execute query.');

   if (db_num_rows($res)==1) {
      // Exactly one row == exactly one default, perfect.
      $row = db_fetch_next($res);
      $default = $row['id'];
    } else {
      // Unsure.
      $default = '';
    }
    return $default;
}

/* Return an HTML SELECT box containing valid choices for incident statuses.
 * Input: name = The HTML name of the selection box.
 *        default = Optionally, the ID of the default selection. If not
 *                  given, the database default status is used as selection
 *                  default.
 *        extras = Optionally, an array [id]=>label with extra statuses that
 *                 do not come from the database, and that are prefixed
 *                 before the database statuses (typically "Select Status").
 * Output: HTML string with full <select> block.
 */
function getIncidentStatusSelection($name, $default='', $extras=array()) {
   $output = sprintf("<select name=\"%s\">\n", htmlentities($name));
   $statuses = getIncidentStatus($extras);
   if ($default=='') {
      $default = getIncidentStatusDefault();
   }
   foreach ($statuses as $i=>$l) {
      $output .= sprintf("<option value=\"%s\" %s>%s</option>\n", htmlentities($i), ($i == $default) ? "SELECTED" : "", htmlentities($l));
   }
   $output .= "</select>";
   return $output;
}

function getIncidentTypes() {
   $res = db_query('SELECT id, label FROM incident_types ORDER BY id')
   or die('Unable to connect to database.');

   $types=array();
   while ($row = db_fetch_next($res)) {
      $types[$row["id"]]=$row["label"];
   }
   return $types;
}

/* Return the current incident type ID system default. If there is no
 * explicit default set, return an empty string. */
function getIncidentTypeDefault() {
   $res = db_query('SELECT id FROM incident_types WHERE isdefault')
   or die('Unable to execute query.');

   if (db_num_rows($res)==1) {
      // Exactly one row == exactly one default, perfect.
      $row = db_fetch_next($res);
      $default = $row['id'];
   } else {
      // Unsure.
      $default = '';
   }
   return $default;
}

/* Return an HTML SELECT box containing valid choices for incident types.
   When a default choice is not given (""), fetch system default.*/
function getIncidentTypeSelection($name, $default='') {
   $output = sprintf("<select name=\"%s\">\n", htmlentities($name));
   $states = getIncidentTypes();
   if ($default=='') {
      $default = getIncidentTypeDefault();
   }
   foreach ($states as $i=>$l) {
      $output .= sprintf("<option value=\"%s\" %s>%s</option>\n", htmlentities($i), ($i == $default) ? "SELECTED" : "", htmlentities($l));
   }
   $output .= "</select>";
   return $output;
}

function getOpenIncidents() {
   $res = db_query(
      "SELECT   i.id as incidentid,
                extract(epoch from created), 
                u1.lastname as creator_lastname,
                u1.firstname as creator_firstname,
                u1.email as creator_email,
                u1.phone as creator_phone, 
                extract(epoch from i.updated), 
                u2.lastname as updatedby_lastname,
                u2.firstname as updatedby_firstname,
                u2.email as updatedby_email,
                u2.phone as updatedby_phone,
                s2.label as state,
                s1.label as status, 
                t.label as type,
                a.ip as ip
         FROM   incidents i, incident_status s1, incident_states s2,
                incident_types t, users u1, users u2, incident_addresses a
         WHERE  i.status = s1.id
         AND    i.state = s2.id
         AND    i.type = t.id
         AND    i.creator = u1.id
         AND    i.updatedby = u2.id
         AND    i.id = a.incident
         AND    s1.label IN ('open', 'stalled')")
   or die("Unable to connect to database.");

   $incidents=array();
   while ($row = db_fetch_next($res)) {
      $incidents[$row["incidentid"]]=$row;
   }
   return $incidents;
}

function getIncident($id) {
   // get basic info
   $res = db_query(q('SELECT   id as incidentid,
                extract(epoch from created) as created,
                creator,
                extract(epoch from updated) as updated,
                updatedby,
                state,
                status,
                type
      FROM incidents
      WHERE id=%id', array('%id'=>$id)))
   or die("Unable to execute query 1.");

   if (db_num_rows($res) == 0) {
      return false;
   }

   $row = db_fetch_next($res);
   $data = $row;

   // get ip addresses
   pg_free_result($res);
   $res = db_query(q('SELECT ip,hostname,constituency,addressrole FROM incident_addresses WHERE incident = %id', array('%id'=>$id)))
   or die("Unable to execute query 2.");

   $ips = array();
   while ($row = db_fetch_next($res)) {
      array_push($ips, array(
         'ip'=>$row["ip"],
         'hostname'=>$row['hostname'],
         'constituency'=>$row['constituency'],
         'addressrole'=>$row['addressrole']));
   }
   $data["ips"] = $ips;

   // get users
   db_free_result($res);
   $res = db_query(q("SELECT userid FROM incident_users WHERE incidentid = '%id'", array('%id'=>$id)))
   or die("Unable to execute query 3.");

   $users = array();
   while ($row = db_fetch_next($res)) {
      array_push($users, $row["userid"]);
   }
   $data["users"] = $users;

   return $data;
}

function showOpenIncidentSelection($name) {
   $incidents = getOpenIncidents();
   $count = count($incidents);
   if ($count == 0) {
      return 0;
   }

   printf("<select name=\"%s\">\n", htmlentities($name));

   foreach ($incidents as $i=>$data) {
      printf("<option value=%s>%s: %s (%s)</option>\n",
         htmlentities($i),
         normalize_incidentid($i),
         $data["ip"],
         $data["type"]);
    }
    printf("</select>");
    return $count;
}

function addIPtoIncident($ip, $incident,$role=0) {
   $networkid = categorize($ip);
   if (defined('CUSTOM_FUNCTIONS') && function_exists("custom_categorize")) {
      $networkid = custom_categorize($ip, $networkid);
   }
   $constituencyID = getConstituencyIDbyNetworkID($networkid);
   $hostname = @gethostbyaddr($ip);
   $_SESSION['active_ip'] = $ip;

   $res = db_query(q('
      INSERT INTO incident_addresses
      (id, incident, ip, addressrole, hostname, constituency,
        added, addedby, updated, updatedby)
      VALUES
      (nextval(\'incident_addresses_sequence\'), %incidentid, %ip,
       %addressrole, %hostname, %constituency, CURRENT_TIMESTAMP, %userid, 
       CURRENT_TIMESTAMP, %userid)', array(
         '%incidentid'=>db_masq_null($incident),
         '%ip'=>db_masq_null($ip),
         '%hostname'=>db_masq_null($hostname),
         '%constituency'=>$constituencyID,
         '%addressrole'=>$role,
         '%userid'=>db_masq_null($_SESSION["userid"]))
   ));
   if (!$res) {
      airt_error('DB_QUERY', 'incident.plib:'.__LINE__,
                 t('Could not add IP to incident'));
      Header("Location: $_SERVER[PHP_SELF]");
      return;
   }
}

function createIncident($state,$status,$type) {
   $res        = db_query("select nextval('incidents_sequence') as incidentid")
                  or die("Unable to execute query 2.");
   $row        = db_fetch_next($res);
   $incidentid = $row["incidentid"];
   $_SESSION['incidentid'] = $incidentid;
   db_free_result($res);

   $res = db_query(sprintf(
      "insert into incidents
      (id, created, creator, updated, updatedby, state, status, type)
      values
      (%s, CURRENT_TIMESTAMP, %s, CURRENT_TIMESTAMP, %s, %s, %s, %s)",
         $incidentid,
         $_SESSION["userid"],
         $_SESSION["userid"],
         $state == "" ? 'NULL' : $state ,
         $status == "" ? 'NULL' : $status ,
         $type == "" ? 'NULL' : $type
      )
   ) or die("Unable to execute query 3.");
   db_free_result($res);

   addIncidentComment("Incident created", "", "");
   addIncidentComment(sprintf("state=%s, status=%s, type=%s",
      getIncidentStateLabelByID($state),
      getIncidentStatusLabelByID($status),
      getIncidentTypeLabelById($type)), "", "");

   return $incidentid;
}

function removeIPfromIncident($ip, $incident, $role) {
   generateEvent("incidentdelip", array(
      "incidentid" => $incident,
      "ip" => $ip,
      "addressrole" => $role
   ));

   $res = db_query(q('
      DELETE FROM incident_addresses
      WHERE ip=%ip
      AND   incident=%incidentid
      AND   addressrole=%addressrole', array(
      '%ip'=>db_masq_null($ip),
      '%incidentid'=>db_masq_null($incident),
      '%addressrole'=>db_masq_null($role))
   ))
   or die("Unable to execute query.");
}

/* Fetch the label of an incident state by ID */
function getIncidentStateLabelByID($id) {
   # $conn = db_connect(DBDB, DBUSER, DBPASSWD)
   # or die("unable to connect to database.");

   $res = db_query(sprintf("
      SELECT label
      FROM   incident_states
      WHERE  id='$id'", $id))
   or die("Unable to fetch state label");

   if (db_num_rows($res)) {
      $row = db_fetch_next($res);
      $out = $row["label"];
   } else {
      $out = "unknown";
   }

   # db_close($conn);

   return $out;
}

/* Fetch the label of an incident status by ID */
function getIncidentStatusLabelByID($id) {
   # $conn = db_connect(DBDB, DBUSER, DBPASSWD)
   # or die("unable to connect to database.");

   $res = db_query(sprintf("
      SELECT label
      FROM   incident_status
      WHERE  id='$id'", $id))
   or die("Unable to fetch status label");

   if (db_num_rows($res)) {
      $row = db_fetch_next($res);
      $out = $row["label"];
   } else {
      $out = "unknown";
   }

   # db_close($conn);

   return $out;
}

/* Fetch the label of an incident type by ID */
function getIncidentTypeLabelByID($id) {
   # $conn = db_connect(DBDB, DBUSER, DBPASSWD)
   # or die("unable to connect to database.");

   $res = db_query(sprintf("
      SELECT label
      FROM   incident_types
      WHERE  id='$id'", $id))
   or die("Unable to fetch status label");

   if (db_num_rows($res)) {
      $row = db_fetch_next($res);
      $out = $row["label"];
   } else {
      $out = "unknown";
   }

   # db_close($conn);

   return $out;
}

function addUsertoIncident($userid, $incident) {
   # $conn = db_connect(DBDB, DBUSER, DBPASSWD)
   # or die("unable to connect to database.");

   $res = db_query(sprintf("
      INSERT INTO incident_users
      (id, incidentid, userid, added, addedby)
      VALUES
      (nextval('incident_users_sequence'), %s, %s, CURRENT_TIMESTAMP, %s)",
         db_masq_null($incident),
         db_masq_null($userid),
         db_masq_null($_SESSION["userid"])
      ))
   or die("Unable to execute query.");
   # db_close($conn);

   generateEvent("incidentadduser", array(
      "incidentid" => $incident,
      "userid" => $userid
   ));
}

/* Remove a user from an incdient id. Does not return any value */
function removeUserfromIncident($userid, $incident) {
   generateEvent("incidentdeluser", array(
      "incidentid" => $incident,
      "userid" => $userid
   ));

   # $conn = db_connect(DBDB, DBUSER, DBPASSWD)
   # or die("unable to connect to database.");

   $res = db_query(sprintf("
      DELETE FROM incident_users
      WHERE userid=%s
      AND   incidentid=%s",
         db_masq_null($userid),
         db_masq_null($incident)
      ))
   or die("Unable to execute query.");
   # db_close($conn);
}

/* Return an HTML formatted string containing the basic incident data (type,
 * state and status. All input variables may be "", which leads to a system
 * default selection.
 */
function formatBasicIncidentData($type, $state, $status) {
   $output = "<table>\n";
   $output .= "  <tr>\n";
   $output .= "    <td>Incident type</td>\n";
   $output .= "    <td>".getIncidentTypeSelection("type", $type)."</td>\n";
   $output .= "    <td><a target=\"airthelp\" href=\"$_SERVER[PHP_SELF]?action=showtypes\">Help</a></td>\n";
   $output .= "  </tr>\n";
   $output .= "  <tr>\n";
   $output .= "    <td>Incident state</td>\n";
   $output .= "    <td>".getIncidentStateSelection("state", $state)."</td>\n";
   $output .= "    <td><a target=\"airthelp\" href=\"$_SERVER[PHP_SELF]?action=showstates\">Help</a></td>\n";
   $output .= "  </tr>\n";
   $output .= "  <tr>\n";
   $output .= "    <td>Incident status</td>\n";
   $output .= "    <td>".getIncidentStatusSelection("status", $status)."</td>\n";
   $output .= "    <td><a target=\"airthelp\" href=\"$_SERVER[PHP_SELF]?action=showstatus\">Help</a></td>\n";
   $output .= "  </tr>\n";
   $output .= "</table>\n";

   return $output;
}


/* Produces a simple HTML edit form to edit an IP address' data.
 * Will be expanded in the future.
 * Requires an incident ID and an IP address in dot notation (could
 * also have been a single incident_address ID, would be better).
 * Returns a HTML formatted string.
 */
function editIPform($incidentid,$ip) {
   // Retrieve the full address assignment data.
   $res = db_query(q('SELECT incident_addresses.id as id,
                ip,hostname,constituency,addressrole,
                to_char(added,\'YYYY-MM-DD HH24:MI\') as added,
                u1.email as addedby,
                to_char(updated,\'YYYY-MM-DD HH24:MI\') as updated,
                u2.email as updatedby
      FROM      incident_addresses
      FULL JOIN users u1 ON u1.id=addedby
      LEFT JOIN users u2 ON u2.id=updatedby
      WHERE     incident=%incidentid AND ip=%ip
      ', array('%incidentid'=>$incidentid, '%ip'=>db_masq_null($ip))))
   or airt_error('DB_QUERY', __FILE__.':'.__LINE__,
                 t('Could not fetch IP address details'));
   if (db_num_rows($res)>0) {
      $row = db_fetch_next($res);
      $id           = $row['id'];
      $ip           = $row['ip'];
      $addressrole  = $row['addressrole'];
      $hostname     = $row['hostname'];
      $constituency = $row['constituency'];
      $added        = $row['added'];
      $addedby      = $row['addedby'];
      $updated      = $row['updated'];
      $updatedby    = $row['updatedby'];
   } else {
      die('Could not find assigned IP address.');
   }

   $o = sprintf("<form method=\"POST\" action=\"%s\">\n", $_SERVER['PHP_SELF']);
   $o .= sprintf("<input type=\"HIDDEN\" name=\"action\" value=\"updateip\">\n");
   $o .= sprintf("<input type=\"HIDDEN\" name=\"id\" value=\"%d\">\n", $id);
   $o .= sprintf("<input type=\"HIDDEN\" name=\"ip\" value=\"%s\">\n", $ip);
   $o .= sprintf("<input type=\"HIDDEN\" name=\"addressrole\" value=\"%s\">\n", $addressrole);
   $o .= sprintf("<input type=\"HIDDEN\" name=\"incidentid\" value=\"%d\">\n",
      $incidentid);
   $o .= "<table>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>IP address</td>\n";
   $o .= sprintf("    <td>%s</td>\n", $ip);
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>Host name</td>\n";
   $o .= sprintf("    <td>%s</td>\n", $hostname);
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>Role in incident</td>\n";
   $o .= sprintf("    <td>%s</td>\n", getAddressRolesSelection('addressrole',$addressrole, array(''=>'Not set')));
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>Constituency</td>\n";
   $o .= sprintf("    <td>%s</td>\n", getConstituencySelection('constituency',$constituency));
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>Added</td>\n";
   $o .= sprintf("    <td>%s</td>\n", $added);
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>Added by</td>\n";
   $o .= sprintf("    <td>%s</td>\n", $addedby);
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>Updated</td>\n";
   $o .= sprintf("    <td>%s</td>\n", $updated);
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>Updated by</td>\n";
   $o .= sprintf("    <td>%s</td>\n", $updatedby);
   $o .= "  </tr>\n";
   $o .= "  <tr>\n";
   $o .= "    <td>&nbsp;</td>\n";
   $o .= "    <td><input type=\"submit\" value=\"Update\"></td>\n";
   $o .= "  </tr>\n";
   $o .= "</table>\n";
   $o .= "</form>\n";

   return $o;
}


/* Attempts to update the incident_addresses table with new data.
 * Works on a unique ID for the combination (incident,ipadress).
 * Returns void.
 */
function updateIPofIncident($id,$constituency,$addressrole) {
   $q = q('UPDATE incident_addresses
      SET constituency=%constituency,
          addressrole=%addressrole,
          updated=CURRENT_TIMESTAMP,
          updatedby=%updatedby
      WHERE id=%id', array(
         '%constituency'=>$constituency,
         '%addressrole'=>$addressrole,
         '%updatedby'=>$_SESSION['userid'],
         '%id'=>$id));
   $res = db_query($q)
   or airt_error('DB_QUERY', __FILE__.':'.__LINE__,
                 t('Could not update IP with incident'));
}


/* Update basic incident data. For convenience reasons, all data fields
 * except the ID may be left unspecified (== ""), in which case they will
 * not be touched. If all fields are "", no update is done at all.
 * Relevant automatic fields will be generated accordingly.
 * Returns void.
 */
function updateIncident($id,$state,$status,$type) {
   // Problem case: no ID given.
   if ($id=='') {
      die('No ID given to update request.');
   }

   // Special case: no work to be done.
   if ($state=='' && $status=='' && $type=='') {
      return;
   }

   // Compile the variable part of the SET clause.
   $set = '';
   if ($state!='') {
      $set .= sprintf('state=%d,',$state);
   }
   if ($status!='') {
      $set .= sprintf('status=%d,',$status);
   }
   if ($type!='') {
      $set .= sprintf('type=%d,',$type);
   }

   // Add the fixed part (we know for sure there is at least one variable
   // part).
   $set .= sprintf('updated=CURRENT_TIMESTAMP,updatedBy=%d', $_SESSION['userid']);

   // Create the whole query.
   db_query(q('UPDATE incidents SET %set WHERE id=%id', array('%set'=>$set, '%id'=>$id)));

  return;
}

/* Mass update a list of incidents. Only status and state can be given and
 * will be set to each incident ID in the list.
 * Returns void.
 */
function updateIncidentList($incidentList,$state,$status) {
   foreach ($incidentList as $id) {
      updateIncident($id,$state,$status,'');
   }
   return;
}

/* Return an associative array with address roles.
 * Input: optionally, an array with extra address roles that are not from
 * the database. Typically, "Please select a role"-like inert selections.
 * Array format: array[extra_id]=extra_label. The extra states are prefixed
 * before the states from the database.
 * Output: array[id]=label.
 */
function getAddressRoles($extras=array()) {
   $res = db_query('SELECT id, label FROM address_roles ORDER BY id')
   or airt_error('DB_QUERY', __FILE__.':'.__LINE__,
                 t('Could not get address roles'));

   $out=$extras;
   while ($row = db_fetch_next($res)) {
      $out[$row["id"]]=$row["label"];
   }
   return $out;
}

/* Return an HTML SELECT box containing valid choices for address roles.
 * Input: name = The HTML name of the selection box.
 *        default = Optionally, the ID of the default selection. 
 *        extras = Optionally, an array [id]=>label with extra states that
 *                 do not come from the database, and that are prefixed
 *                 before the database states (typically "Select State").
 * Output: HTML string with full <select> block.
 */
function getAddressRolesSelection($name, $default='', $extras=array()) {
   $output = t('<select name="%name">\n', array(
      '%name'=>htmlentities($name)
   ));
   $roles = getAddressRoles($extras);
   foreach ($roles as $i=>$l) {
      $output .= t('<option value="%id" %selected>%label</option>\n', array(
          '%id'=>htmlentities($i), 
          '%selected'=>($i == $default) ? "SELECTED" : '', 
          '%label'=>htmlentities($l)
      ));
   }
   $output .= "</select>";
   return $output;
}

/* Returns the label associated with an address role id, or an empty string if
 * no such role exists.
 */
function getAddressRoleByID($id) {
   $addressroles = getAddressRoles();
   if (array_key_exists($id, $addressroles)) {
      return $addressroles[$id];
   } else {
      return "";
   }
}
?>
