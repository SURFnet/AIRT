<?php
/*
 * LIBERTY: INCIDENT RESPONSE SUPPORT FOR END-USERS
 * Copyright (C) 2004	Kees Leune <kees@uvt.nl>

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * rt.plib - Connector module for RT
 *
 * $Id$
 */
$public = 1;
require_once 'database.plib';
require_once 'liberty.plib';

/* Check if the provided info is a valid username/password combination.
 * THe function will return -1 on failure; or the userid on success.
 */
function RT_checkLogin($username, $password)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("Unable to connect to database.".db_errormessage());

    $query = sprintf("
        SELECT u.id
        FROM   users u, groups g, groupmembers m
        WHERE  u.id = m.memberid
        AND    m.groupid = g.id
        AND    u.name = '%s'
        AND    g.name = '%s'", 
            $username, 
            CERTGROUP);

    $res = db_query($conn, $query)
    or die("Unable to query database: ".db_errormessage());

    if (db_num_rows($res) == 0) return -1;
    $row = db_fetch_next($res);
    db_close($conn);

    return $row["id"];
} // RT_checkLogin


/* retrieve user info
 * Returns an empty array if user does not exists; or an associative array on
 * success.
 */
function RT_getUserById($id)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("Unable to connect to database.".db_errormessage());

    $res = db_query($conn, sprintf("
        SELECT *
        FROM   users
        WHERE  id=%s", $id))
    or die("Unable to query database: ".db_errormessage());

    if (db_num_rows($res) == -1)
        $output = array();
    else
        $output = db_fetch_next($res);

    db_close($conn);
    return $output;
} // RT_getUserById


/* Find a request tracker queue by name
 * Returns -1 if the queue was not found; or the queue id on success
 */
function RT_getQueueByName($name)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("Unable to connect to database.".db_errormessage());

    /* get correct queue id */
    $res = db_query($conn, "
        SELECT id
        FROM   queues
        WHERE  name = '$name'")
    or die("Error retrieving queue id: ".db_errormessage());

    if (db_num_rows($res) == 0) return -1;
    $row = db_fetch_next($res);
    db_close($conn);

    $queueid = $row["id"];
} // RT_getQueueByName


/* Return an array of open messages in the provides queue
 * Each returned element is a message id
 */
function RT_getNewTicketIds($queue)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("unable to connect to database: ".db_errormessage());

    $res = db_query($conn, 
        "SELECT   t.id
         FROM     tickets t, users u, queues q
         WHERE    t.creator = u.id
         AND      t.queue = q.id
         AND      q.name = '$queue'
         AND      t.status = 'new'
         ORDER BY t.created")
    or die("Unable to query database: ".db_errormessage());

    $output = array(db_num_rows($res));
    $count = 0;
    while ($row = db_fetch_next($res))
    {
        $id        = $row["id"];
        $output[$count++] = $id;
    } // while
    
    return $output;
} // RT_getNewMessageIds


/* Return a ticket by ticket id 
 * An associative array.
 */
function RT_getTicketById($id)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("Unable to connect to database: ".db_errormessage());

    $res = db_query($conn,
        "SELECT *
         FROM   tickets
         WHERE  id = $id")
    or die("Unable to query database: ".db_errormessage());

    if (db_num_rows($res) == 0) 
        $row = array();
    else
        $row = db_fetch_next($res);

    db_close($conn);
    return $row;
} // RT_getTicketById


function RT_getAttachmentById($id)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("Unable to connect to database: ".db_errormessage());

    $res = db_query($conn,
        "SELECT *
         FROM   attachments
         WHERE  id=$id")
    or die("Unable to query database: ".db_errormessage());

    if (db_num_rows($res) == 0) 
        $row = array();
    else
        $row = db_fetch_next($res);

    db_close($conn);
    return $row;
} // RT_getAttachmentById($id)


/* Retrieve a list of attachment IDs associated with a certain ticket 
 * Returns an array contain attachment IDs, or an empty array when none are
 * found.
 */
function RT_getAttachmentsOfTicket($id)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("Unable to connect to database: ".db_errormessage());

    $query = sprintf("
        SELECT a.id
        FROM   attachments a, transactions t
        WHERE  t.ticket = '%s'
        AND    a.transactionid = t.id
        ", $id);
    $res = db_query($conn, $query)
    or die("Unable to query database: ".db_errormessage());

    $output = array(db_num_rows($res));
    $count = 0;
    while ($row = db_fetch_next($res))
        $output[$count++] = $row["id"];

    return $output;
} // RT_getAttachmentsOfTicket



function RT_setTicketField($ticketid, $field, $value)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("unable to connect to database: ".db_errormessage());

    // update ticket status
    $res = db_query($conn, sprintf("
        UPDATE tickets
        SET    $field = $value
        WHERE  id = $ticketid"))
    or die("Unable to update status: ".db_errormessage());

    db_close($conn);
} // RT_setTicketField


function RT_addTransaction($transaction)
{
    $conn = db_connect(RTNAME, RTUSER, RTPASSWD)
    or die("unable to connect to database: ".db_errormessage());

    // update ticket status
    $res = db_query($conn, $transaction->getInsertStatement())
    or die("Unable to insert transaction: ".db_errormessage());

    db_close($conn);
} // RT_addTransaction

function RT_masq_null($str) {
    return ($str == "" ? "NULL": "'$str'");
}

class RT_Transaction 
{
    var $effectiveticket,
        $ticket,
        $type,
        $field,
        $oldvalue,
        $newvalue,
        $creator,
        $created;

    function setEffectiveTicket($id) { $this->effectiveTicket = $id; }
    function setTicket($id)          { $this->ticket = $id; }
    function setField($str)          { $this->field = $str; }
    function setType($str)           { $this->type = $str; }
    function setOldValue($str)       { $this->oldvalue = $str; }
    function setNewValue($str)       { $this->newvalue = $str; }
    function setCreator($id)         { $this->creator = $id; }
    function setCreated($str)        { $this->created = $str; }

    function getEffectiveTicket()    { return $this->effectiveticket; }
    function getTicket()             { return $this->ticket; }
    function getField()              { return $this->field; }
    function getType()               { return $this->type; }
    function getOldValue()           { return $this->oldvalue; }
    function getNewValue()           { return $this->newvalue; }
    function getCreator()            { return $this->creator; }
    function getCreated()            { return $this->created; }


    function getInsertStatement()
    {
        return sprintf("
            INSERT INTO transactions
            (effectiveticket, ticket, type, field, oldvalue, newvalue,
             creator, created)
            VALUES
            (%s, %s, %s, %s, %s, %s, %s, %s)",
            $this->effectiveTicket, $this->ticket, RT_masq_null($this->field), 
            RT_masq_null($this->type), RT_masq_null($this->oldvalue), 
            RT_masq_null($this->newvalue), $this->creator, 
            RT_masq_null($this->created));
    }

} // RT_Transaction
    
    

/* EOF */
?>
