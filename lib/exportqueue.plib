<?php
/* vim: syntax=php tabstop=3 shiftwidth=3
 *
 * AIRT: APPLICATION FOR INCIDENT RESPONSE TEAMS
 * Copyright (C) 2005   Tilburg University, The Netherlands

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * exportqueue.plib -- main library for the export queue
 * ("airt_export" command).
 * 
 * $Id$
 */

// This is the common library for all export queue functions, both for CLI
// and for HTTP use.


require_once LIBDIR.'/airt.plib';


///// CLI functions ///////////////////////////////////////////////////////////

/* Produce info on stdout (when user asked for --help). */
function printUsage() {
   global $WRAPPERS;

   echo t('Task export program, part of the AIRT suite.')."\n";
   echo t('Copyright (C) 2005   Tilburg University, The Netherlands.')."\n";
   echo t('Usage: airt_export [--help] [--noqueue] [--verbose]')."\n";
   echo   '         '.t('[--result-id=ID] [--result-code=CODE]')."\n";
   echo   '         '.t('[--result-msg="message here"]')."\n";

   // Enumerate all registered wrappers.
   if (count($WRAPPERS)>0) {
      echo t('Available wrappers:');
      foreach ($WRAPPERS as $wrapper=>$execpath) {
         echo ' '.$wrapper;
      }
      echo "\n";
   }

}// printUsage


/* Task spawner, the Unix way. Does the traditional fork() and exec() trick,
 * and leaves the spawned task running as a child of the parent of
 * airt_export, not as a child of airt_export itself.
 * Input:  task = The fully qualified path name of the task to start.
 *         params = Array with all CLI parameters to be provided to the task.
 *                  See doc of pcntl_exec for exact specifications.
 * Output: "" when task was spawned successfully, error string on failure.
 *         It seems unnecessary to return the child PID, as we do not
 *         foresee a "kill background task" option any time soon. If we need
 *         one, start using pass-by-reference parameters.
 */ 
function spawnTask($task,$params=array()) {
   // Check whether we have any chance of successfully executing the task.
   if (!is_executable($task)) {
      // Nope.
      return t('%task is not executable.',
               array('%task'=>$task));
   }

   // Divide & conquer.
   $child = pcntl_fork();
   if ($child==-1) {
     // Could not fork!?
     return t('Could not fork.');
   } else if ($child>0) {
     // Forked successfully and we are the parent.
     return '';
   }

   // We are the child. Hello, world!
   // Detach from the controlling terminal, we run as a daemon.
   if (!posix_setsid()) {
     fwrite(STDERR, "ERROR: Could not detach from terminal.\n");
     exit(1);
   }

   // Replace ourselves with the target task. Notice that we cannot signal
   // any problem back to the parent here.
   pcntl_exec($task,$params);
   // and we'll never ever should get here.
   fwrite(STDERR, "ERROR: Entered the twilight zone!?");
   exit(1);

}// spawnTask


/* Message to user on stdout, is silent when no --verbose switch was given.
 * Input: message = The string to display when --verbose, without line feed.
 * Output: void.
 */
function msg($message) {
   global $OPTIONS;
   if (!$OPTIONS['--verbose']) {
      return;
   } else {
      echo "$message\n";
   }
}


///// HTTP functions //////////////////////////////////////////////////////////

// None yet.


///// Common (SQL) functions //////////////////////////////////////////////////

/* Returns all items in the queue, ordered by task ID.
 * Input: itemArray = Variable to put the queue items into: array[taskid]=''.
 *        error = Variable to write the error message to.
 * Output: 0 on success, 1 on failure, with $error containing a message.
 */
function queueList(&$itemArray, &$error) {
   $itemArray = array();
   $error = 'Not yet implemented.';
   return 1;
}// queueList


/* Inserts a new task into the queue.
 * Input: task = The task name to run, e.g. 'none'. Leave out 'wrapper_'.
 *        params = The parameter string. Replace spaces
 *           by '!' like for Nagios: '-f!foo!-b!bar'. May be ''.
 *        scheduled = A time string in ISO8601 format when the
 *           task must be started. When '', task will run ASAP.
 *        output = Variable to write the new task ID or the error msg to.
 * Output: 0 on success, $output contains new task ID, or 1 on failure,
 *    $output contains error msg.
 */
function queueItemInsert($task, $params, $scheduled, &$output) {
   $output = 'Not yet implemented.';
   return 1;
}// queueItemInsert


/* Returns the details of a given item. Does not touch the queue at all.
 * Input: taskID = The task ID as returned by queueList() or queueInsertItem().
 *        output = array[key]=value, with key in (id,task,params,created,
 *           scheduled,started,ended,result); or the error message.
 * Output: 0 on success, $output contains task details, or 1 on failure,
 *    $output contains error msg.
 */
function queueItemPeek($taskID, &$output) {
   $output = 'Not yet implemented.';
   return 1;
}// queueItemPeek


/* Marks an existing queue item as started.
 * Input: taskID = The ID as returned by queueList() or queueInsertItem().
 *        started = The ISO8601 time string when the item got
 *           started. When '', current system time will be used.
 *        error = Variable to write the error message to.
 * Output: 0 on success, 1 on failure, with $error containing the message.
 */
function queueItemSetStarted($taskID, $started, &$error) {
   $error = 'Not yet implemented.';
   return 1;
}// queueItemSetStarted


/* Marks an existing queue item as ended.
 * Input: taskID = The ID as returned by queueList() or queueInsertItem().
 *        ended = The ISO8601 time string when the item got
 *           started. When '', current system time will be used.
 *        result = The standard result code plus a possible message,
 *           together as one string.
 *        error = Variable to write the error message to.
 * Output: 0 on success, 1 on failure, with $error containing the message.
 */
function queueItemSetEnded($taskID, $ended, $result, &$error) {
   $error = 'Not yet implemented.';
   return 1;
}// queueItemSetEnded


/* Purges all items that have expired from the queue. Does not make a
 * difference between items on the basis of status; only looks at the
 * creation time. Do not set the expiration period too short or you may
 * cause problems with long-running tasks.
 * Input: maxAge = Number of seconds that an item may stay in the queue.
 *        error = Variable to write the error message to.
 * Output: 0 on success, 1 on failure, with $error containing the message.
 */
function queuePurge($maxAge, &$error) {
   $error = 'Not yet implemented.';
   return 1;
}


?>
