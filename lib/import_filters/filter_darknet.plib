<?php
/* vim: syntax=php tabstop=3 shiftwidth=3
 *
 * AIRT: APPLICATION FOR INCIDENT RESPONSE TEAMS
 * Copyright (C) 2005   Tilburg University, The Netherlands

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * filter_darknet.plib -- filter function for darknet reports
 * 
 * $Id$
 */

/* The Cymru import filter expects input as sent by Team Cymru. For each URL in
 * the message, it will attempt to retrieve the corresponding file using the
 * username and password specified in the configuration file. The filter uses
 * PHP's curl extensions for retrieving the data and provides a means to set
 * additional Curl parameters from the configuration file. Define an array
 * $CURLOPTS which uses a Curl option as key and the value as value. For a list
 * of support Curl options, please visit the PHP documentation at
 * www.php.net/manual/en/function.curl-setopt.php.
 */
require_once ETCDIR.'/darknet.cfg';

/* Fetch a Cymru report from the specified URL and place it in the report
 * parameter.
 * Returns 0 on success, 1 on failure
 */

function darknet_getReport($url, &$report) {
   global $CURLOPTS;

   // initialise curl session and set username and password
   $ch = curl_init($url);

   // local curl options
   if (isset($CURLOPTS)) {
      foreach ($CURLOPTS as $key=>$val) {
         curl_setopt($ch, $key, $val);
      }
   }

   // fetch page
   $userpass = sprintf("%s:%s", CYMRU_USERNAME, CYMRU_PASSWORD);
   curl_setopt($ch, CURLOPT_USERPWD, $userpass);
   curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_ANY);
   curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

   $report['body'] = curl_exec($ch);
   if ($report['body'] == 0) {
      print "Error retrieving $url: ".curl_error()."\n";
      curl_close($ch);
      return 1;
   }

   // URL analysis
   $tokens = explode('/', $url);
   $report['type'] = $tokens[5];
   $report['date'] = $tokens[7];
   $report['as'] = substr($tokens[8], 0, strpos($tokens[8], '.'));

   curl_close($ch);
   return 0;
}

/* Translate the retrieved report into an associative array. 
 * Returns 0 on success, 1 on failure
 */
function darknet_analyzeReport(&$report) {
   $rmatch = array();
   $count = 0;
   preg_match_all('/^(.*)$/m', $report['body'], $rmatch);
   foreach ($rmatch[1] as $line) {
      if ($line == '') {
         continue;
      }
      $tuple = explode('|', $line);
      $report['incidents'][$count]['details'] = $line;
      $report['incidents'][$count]['ip'] = trim($tuple[1]);
      $report['incidents'][$count]['meta'] = trim($tuple[2]);
      $report['incidents'][$count]['owner'] = trim($tuple[3]);
      // extract date and time from meta
      $dtmatch = array();
      if (preg_match('/^([0-9-]+)/', $report['incidents'][$count]['meta'], $dtmatch) == 0) {
         $report['incidents'][$count]['date'] = 'unknown';
      } else {
         $report['incidents'][$count]['date'] = $dtmatch[1];
      }
      $dtmatch = array();
      if (preg_match('/ ([0-9:]+)/', $report['incidents'][$count]['meta'], $dtmatch) == 0) {
         $report['incidents'][$count]['time'] = 'unknown';
      } else {
         $report['incidents'][$count]['time'] = $dtmatch[1];
      }
      $count++;
   }
   return 0;
}

/* format the report into importqueue readable data 
 * pre: $reports is an array contain reports.
 *   Each report is an associative array containing the following keys
 *   ['incidents']['type']        type of incident
 *   ['incidents']['as']          autonomous system of IP addresses
 *   ['incidents']['date']        date of the report
 *   ['incidents'][n]['ip']       ip address of the offender
 *   ['incidents'][n]['date']     date of the incident
 *   ['incidents'][n]['time']     time of the incident
 *   ['incidents'][n]['meta']     date, time and possible extra info
 *   ['incidents'][n]['owner']    owner of the AS
 *   ['incidents'][n]['details']  the full log line
 */
function filter_out($reports, &$output) {
   $dom = domxml_new_doc('1.0');
   $airt = $dom->add_root('airt');

   $id = 0;
   foreach ($reports as $report) {
      foreach ($report['incidents'] as $incident) {
         // create elements
         $queuedata_el = $dom->create_element('queuedata');
         $status_el = $dom->create_element('status');
         $sender_el = $dom->create_element('sender');
         $type_el = $dom->create_element('type');
         $summary_el = $dom->create_element('summary');

         // set values
         $queuedata_el->set_attribute('ref', "#$id");
         $status_el->set_content('open');
         $sender_el->set_content('Team Cymru');
         $type_el->set_content('Cymru report: '.$report['type']);
         $summary_el->set_content('Cymru report: '.$report['type'].' '.$incident['ip']);

         // create data structure
         $queuedata_el->append_child($status_el);
         $queuedata_el->append_child($sender_el);
         $queuedata_el->append_child($type_el);
         $queuedata_el->append_child($summary_el);

         // create incident element
         $incident_el = $dom->create_element('incident');
         $techinfo_el = $dom->create_element('technicalInformation');
         $ip_el       = $dom->create_element('ip');
         $host_el     = $dom->create_element('hostname');
         $resolv_el   = $dom->create_element('time_dns_resolving');
         $logging_el  = $dom->create_element('logging');
         $time_el     = $dom->create_element('incident_time');

         // set values
         $incident_el->set_attribute('id', $id);
         $ip_el->set_content($incident['ip']);
         $host_el->set_content(gethostbyaddr($incident['ip']));
         $resolv_el->set_content(Date('Y-m-d H:i:s'));
         $logging_el->set_content($incident['details']);
         $time_el->set_content($incident['date'].' '.$incident['time']);

         // create structure
         $techinfo_el->append_child($ip_el);
         $techinfo_el->append_child($host_el);
         $techinfo_el->append_child($time_el);
         $techinfo_el->append_child($resolv_el);
         $techinfo_el->append_child($logging_el);

         $incident_el->append_child($techinfo_el);

         // add to root
         $airt->append_child($queuedata_el);
         $airt->append_child($incident_el);

         $id++;
      } // foreach $incident
   } // foreach $report

   $output = $dom->dump_mem(true);
   return 0;
}

/* The actual filter */
function filter_darknet($input, &$output, $verbosity=FALSE) {
   $report = array();

   /* make sure we have the required config */
   if (!defined('CYMRU_USERNAME') || !defined('CYMRU_PASSWORD')) {
      print "Missing username/password in Cymru filter\n";
      return 1;
   }

   /* start fetching */
   $matches = array();
   $reports = array();
   if (preg_match_all('/^<(.*)>.$/m', $input, $matches) > 0) {
      foreach ($matches[1] as $url) {
         if ($verbosity) {
            print "Attempting to retrieve $url\n";
         }
         if (darknet_getReport($url, $report)) {
            print "Error fetching Cymru report from $url\n";
            return 1;
         }
         if (darknet_analyzeReport($report)) {
            print "Error analyzing Cymru report\n";
            return 1;
         }
         $reports[] = $report;
      }
   } else {
      if ($verbosity) {
         print "No reports found.\n";
      }
   }

   filter_out($reports, $output);
   return 0;
}
?>
