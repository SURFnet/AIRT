<?php
/* vim: syntax=php tabstop=3 shiftwidth=3
 * $Id$
 *
 * AIRT: APPLICATION FOR INCIDENT RESPONSE TEAMS
 * Copyright (C) 2005   Tilburg University, The Netherlands

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * importqueue.plib -- main library for the import queue ("import" command).
 * 
 * $Id$
 */

// Libraries for the import queue system. These libraries are shared between
// many access points, such as Web pages, command line tools, and web
// services.

// In case the import queue configuration isn't in order, there is no
// reasons to continue. End the attempt to load the libraries with a loud
// bang.
if (!defined('ETCDIR') || !file_exists(ETCDIR.'/importqueue.cfg')) {
   print("Import queue depends on web service. Missing configuration file.\n");
   exit;
}
if (!defined('AIRT_IMPORTQUEUE_METATYPE_INCIDENT')) {
   define('AIRT_IMPORTQUEUE_METATYPE_INCIDENT', 'incident');
}
if (!defined('AIRT_IMPORTQUEUE_METATYPE_CONTACT')) {
   define('AIRT_IMPORTQUEUE_METATYPE_CONTACT', 'contact');
}
$AIRT_IMPORTQUEUE_METATYPES = Array(
   AIRT_IMPORTQUEUE_METATYPE_INCIDENT,
   AIRT_IMPORTQUEUE_METATYPE_CONTACT
);

require_once LIBDIR.'/airt.plib';
require_once ETCDIR.'/importqueue.cfg';
require_once ETCDIR.'/webservice.cfg';
require_once 'SOAP/Client.php';
require_once LIBDIR.'/incident.plib';
require_once LIBDIR.'/search.plib';
require_once LIBDIR.'/constituency.plib';
require_once LIBDIR.'/mailtemplates.plib';
require_once LIBDIR.'/profiler.plib';


function importqueue_get_filters() {
   global $AIRT_IMPORTFILTER_DIRS;
   $FILTERS=array();

   foreach ($AIRT_IMPORTFILTER_DIRS as $dir) {
      if (!file_exists($dir)) {
         continue;
      }
      $libdir = opendir($dir);
      while ($file = readdir($libdir)) {
         $filter_name = basename($file,'.plib');
         if (substr($filter_name,0,7)=='filter_') {
            // Found a filter library file, source it. Failures to read it or parse
            // it are not handled gracefully, but cause a proper abort with a
            // meaningful message.
            require_once $dir.'/'.$filter_name.'.plib';
            // Proper function installed?
            if (function_exists($filter_name)) {
               // OK, register the filter if we don't have it yet.
               if (array_search(substr($filter_name,7),$FILTERS)===FALSE) {
                  $FILTERS[] = substr($filter_name,7);
               }
            } else {
               // Bad filter, complain and quit.
               fwrite(STDERR, t('ERROR: Bad filter definition file "%s".',
                                array('%s'=>$filter_name)).
                              "\n");
               exit(1);
            }
         }
      }// for each file name
      closedir($libdir);
   }

   return $FILTERS;
}


/* Produce info on stdout (when user asked for --help). */
function printUsage() {

   echo _('Incident import program, part of the AIRT suite.').LF;
   echo _('Copyright (C) 2007   Tilburg University, The Netherlands.').LF;
   echo _(
'Usage: import [--filter=<filter>] [--help] [--noqueue] [--verbose] \\
              [--virtual-host=<virtual_host>] [filename]'
     ).LF;
   echo _(
     'The program reads the import data from stdin if no filename is given.'
     ).LF;

   // Enumerate all registered filters.
   $FILTERS = importqueue_get_filters();
   if (count($FILTERS)>0) {
      echo _('Available filters:');
      foreach ($FILTERS as $filter) {
         echo ' '.$filter;
      }
      echo LF;
   }

}// printUsage


/**
 * Process an AIRT incident
 */
function importIncident($doc, $importqueue, &$error='') {
   for ($count=0; $count < $importqueue->length; $count++) {
      $element = $importqueue->item($count);
      $filter = $element->getAttribute('filter');
      if (empty($filter)) {
         $filter = 'unknown';
      }

      $version = $element->getAttribute('version');
      if (empty($version)) {
         $version = 'unknown';
      }

      if (!$element->hasAttribute('ref')) {
         $error = _('missing ref attribute in xml');
         return false;
      }

      $ref = $element->getAttribute('ref');
      $ref = preg_replace('/^#/', '', $ref);

      $status = $sender = $summary = $type = '';
      $e = $element->getElementsByTagname('status');
      if ($e->length > 0) {
         $status = $e->item(0)->textContent;
      }
      $e = $element->getElementsByTagname('sender');
      if ($e->length > 0) {
         $sender = $e->item(0)->textContent;
      }
      $e = $element->getElementsByTagname('type');
      if ($e->length > 0) {
         $type = $e->item(0)->textContent;
      }
      $e = $element->getElementsByTagname('summary');
      if ($e->length > 0) {
         $summary = $e->item(0)->textContent;
      }

      // fetch appropriate incident
      $xpath = new DOMXPath($doc);
      $objs = $xpath->evaluate("//incident[@id='$ref']");
      $incident = $objs->item(0);

      // create new xml doc of it (can this be done better?)
      $out_dom = new DOMDocument();
      $out_airt = $out_dom->appendChild($out_dom->createElement('airt'));
      $out_airt->appendChild($out_dom->imporTnode($incident, true));
      $content = $out_dom->saveXML();

      // insert
      $newid =
      queueInsertItem(array( 
         'status'=>$status, 'sender'=>$sender, 'type'=>$type,
         'summary'=>$summary, 'content'=>$content, 'filter'=>$filter, 
         'version'=>$version, 'metatype'=>AIRT_IMPORTQUEUE_METATYPE_INCIDENT),
         $error);
      if ($newid === false) {
         // $error has already been filled in by the call to queueinsertitem().
         return false;
      }

      // progress
      if ($verbosity) {
         echo _("queued incident, id=$newid").LF;
         flush();
      }
   } // for

   return true;
} // importIncident


/**
 * Import contact information
 */
function importContact($doc, $contactData, &$error='') {
   foreach ($contactData as $data) {
      $filter = $data->getattribute('filter');
      if (empty($filter)) {
         $filter = 'unknown';
      }

      $version = $data->getattribute('version');
      if (empty($version)) {
         $version = 'unknown';
      }
      $res = $data->getElementsByTagName('sender');
      if ($res->length == 0) {
         $error = _('Missing field sender');
         return false;
      }
      $sender = $res->item(0)->textContent;
      $res = $data->getElementsByTagName('constituency');
      if ($res->length == 0) {
         $error = _('Missing field constituency');
         return false;
      }
      $constituency = $res->item(0)->textContent;
      $res = $data->getElementsByTagName('contact');
      foreach ($res as $contact) {
         $res2 = $contact->getElementsByTagName('name');
         if ($res->length == 0) {
            $error = _('Missing contact name');
            return false;
         }
         $name = $res2->item(0)->textContent;
         $res2 = $contact->getElementsByTagName('email');
         if ($res->length == 0) {
            $error = _('Missing contact email');
            return false;
         }
         $email = $res2->item(0)->textContent;
      }

      $res = $data->getElementsByTagName('networks');
      foreach ($res as $n) {
         $res2 = $n->getElementsByTagName('network');
         if ($res2->length == 0) {
            $error = _('Missing network data');
            return false;
         }
         $res3 = $res2->item(0)->getElementsByTagName('address');
         if ($res3->length == 0) {
            $error = _('Missing network address');
            return false;
         }
         $network = $res3->item(0)->textContent;
         $res3 = $res2->item(0)->getElementsByTagName('netmask');
         if ($res3->length == 0) {
            $error = _('Missing netmask');
            return false;
         }
         $netmask = $res3->item(0)->textContent;
      }
      $out_dom = new DOMDocument();
      $out_airt = $out_dom->appendChild($out_dom->createElement('airt'));
      $out_airt->appendChild($out_dom->importnode($data, true));
      $content = $out_dom->savexml();
      $newid = queueinsertitem(array(
         'status'=>'open', 
         'sender'=>htmlentities($sender), 
         'type'=>'Contact import',
         'summary'=>'New contact: '.htmlentities($constituency), 
         'content'=>$content, 'filter'=>$filter, 'version'=>$version,
         'metatype'=>AIRT_IMPORTQUEUE_METATYPE_CONTACT
      ), $error);
      if ($newid === false) {
         return false;
      }
   } // for
}


/* Actual import function, which presents the standardised XML to the AIRT
 * core.
 * $input      = Standard XML string to import.
 * $error      = String variable to write possible error msg to (pass by ref.).
 * $verbosity  = TRUE when verbose output is requested on stdout.
 * Returns 0 on success, 1 on failure ($error contains error message).
 */
function import($input,&$error,$verbosity=FALSE) {
   global $OPTIONS;

   // Error message will only contain a string when an actual error occurred
   // and the return code is 1.
   $error = '';

   // Everything except the presentation of the incident to the AIRT core
   // database should have been done by now. The rest is optional.
   if ($OPTIONS['--noqueue']) {
      // Just kidding.
      if ($verbosity) {
         echo _('Not actually queueing the incident.').LF;
      }
      return 0;
   }

   // Collect all <queuedata> chunks. They represent the individual incidents
   // that we are going to queue. Then for each found <queuedata> chunk,
   // retrieve the associated <incident> chunk. With the four data elements
   // from the <queuedata> chunk plus the <incident> chunk, call the
   // queueInsertItem() function.

   // Make sure we do not have namespaces. Somehow DOM XML chokes on that
   $xml=preg_replace('/airt:/','',$input);
   $doc = new DOMDocument();
   $dom = $doc->loadXML($xml);
   if ($dom == false) {
      $error = _('Unable to parse xml');
      return 1;
   }

   $importqueue = $doc->getElementsByTagName('queuedata');
   if ($importqueue->length > 0) {
      return importIncident($doc, $importqueue, $error);
   }

   $importqueue = $doc->getElementsByTagName('contactData');
   if ($importqueue->length > 0) {
      return importContact($doc, $importqueue, $error);
   }

   // This is not an error. There just is no work for us.
   return true;
}// import


# TODO: replace this function by "queueItemSetAccepted()" and
# queueItemSetRejected().
/* Update item in queue.
 * $id  = queue item identifier
 * $field = field to update
 * $value = new value of field
 * Returns 0 on success, 1 on failure. Error will contain an error msg
 */
function updateQueueItem($id, $field, $value, &$error) {
   $error = '';
   if (!is_numeric($id)) {
      $error = _('Invalid parameter "id"');
      return 1;
   }
   $query = q('update import_queue set %field = \'%value\', updated = CURRENT_TIMESTAMP where id=\'%id\'', 
      array('%id'=>$id,
      '%field' => db_escape_string($field),
      '%value' => db_escape_string($value)
   ));
   $res = db_query($query);
   if ($res == false) {
      $error = _('Unable to query database').' in importqueue.plib:'.__LINE__;
      return 1;
   }

   return 0;
}


/* retrieve open elements from database.
 *
 * Parameters
 * $elements will contain an associative array of the open queue elements, 
 *           keyed by id.
 * $error will contain an error message, if any
 *
 * Returns true on success, false on failure
 */
function queueGetItems(&$elements, &$error) {
   $error = '';
   $res = db_query(q('SELECT id, created, status, sender, type, summary,
      cache_ip, cache_constituency, cache_mailtemplate, filter, 
      metatype, version
      FROM import_queue
      WHERE status = \'open\'
      ORDER BY cache_ip DESC'));
   if ($res == false) {
      $error = _('Unable to query database').' in importqueue.plib:'.__LINE__;
      return false;
   }
   $elements = array();
   while ($row = db_fetch_next($res)) {
      $elements[$row['id']] = $row;
   }
   return true;
}


/* show a formatted overview of the incident queue
 */
function queueFormatItems() {
   global $toggle;

   defaultTo($toggle, 0);
   $error = '';
   $openips=array();
   $elements = array();

   if (queueGetItems($elements, $error) === false) {
      return;
   }
   if (sizeof($elements) == 0) {
      return _('No items pending<p/>').LF;
   }
   $urlsuffix = 'toggle='.urlencode($toggle);
   foreach (getOpenincidents() as $id=>$data) {
      $openips[$data['ip']] = $id;
   }
   $used_ips = array();
   $out = '<SCRIPT language="JavaScript">'.LF;
   $out .= 'function checkAll() {'.LF;
   $out .= '   window.location = "'.$_SERVER['PHP_SELF'].'?action=toggle&'.$urlsuffix.'"'.LF;
   $out .= '}'.LF;
   $out .= '</SCRIPT>';

   $out .= '<div class="importqueue-overview-body">'.LF;
   $out .= '<table class="horizontal">'.LF;
   $out .= '<tr>'.LF;
   $out .= t('   <th><input type="checkbox" onChange="checkAll()" %checked></th>'.LF,
       array('%checked'=>($toggle == 1) ? 'CHECKED' : ''));
   $out .= '   <th>'._('No.').'</th>'.LF;
   $out .= '   <th>'._('Type').'</th>'.LF;
   $out .= '   <th>'._('Constituency').'</th>'.LF;
   $out .= '   <th>'._('IP Address').'</th>'.LF;
   $out .= '   <th>'._('Preferred Template').'</th>'.LF;
   $out .= '</tr>'.LF;
   // process incidents first
   $count = 0;

   foreach ($elements as $id=>$element) {
      /* only look at metatype incidnet */
      if ($element['metatype'] != AIRT_IMPORTQUEUE_METATYPE_INCIDENT) {
         continue;
      }
      $item = queuePeekItem($id, $error);
      if ($error != '') {
         airt_error('ERR_FUNC', 'importqueue.plib:'.__LINE__);
         return;
      }
      if ($element['cache_mailtemplate'] == '') {
         $element['cache_mailtemplate'] =_('No preferred template');
      }
      $out .= '<tr valign="top">'.LF;
      $out .= '  <td nowrap>'.LF;
      $out .= t('     <input name="checked['.$id.']" %checked type="checkbox" /> '.LF,
         array('%checked'=>($toggle == 1) ? 'CHECKED' : ''));
      $out .= '  </td>'.LF;

      $out .= t('  <td nowrap><a target="airt_queue" href="%url?action=showdetails&id=%id">'.
         $element['id'].'</a></td>'.LF,
         array('%url'=>$_SERVER['PHP_SELF'], '%id'=>$id));;

      $out .= t('  <td><a target="airt_queue" href="%url?action=showdetails&id=%id">%type</a></td>'.LF, array(
         '%url'=>BASEURL.'/importqueue.php',
         '%id'=>$id,
         '%type'=>$element['type']));

      $out .= t("  <td>%cons</td>\n", array('%cons'=>$element['cache_constituency']));
      $out .= t('  <td><a href="%base/search.php?qtype=host&action='.
         urlencode(_('Search')).'&q=%eip">%ip</a></td>'."\n", 
         array('%ip'=>$element['cache_ip'],
               '%base'=>BASEURL,
               '%eip'=>urlencode($element['cache_ip'])));
      $out .= '  <td>'.getMailtemplateSelection('template['.$element['id'].']', 
         $element['cache_mailtemplate'], array(_('No preferred template')=>''))
         .'</td>'.LF;
      $out .= '   <td>'.LF;

      if (getPreviousIncidents($element['cache_ip'], $prev, $error) &&
            filterIncidentsByStatus($prev, 2, $prev2, $error) &&
            filterIncidentsByAge($prev2, 172800, $prev3, $error)) {
         for ($i=0; $i < sizeof($prev3); $i++) {
            $prev = getIncident($prev3[$i]);
            $out .= t(_('<a href="%u?incidentid=%I&action=details">%i</a> closed %c').'<br/>'.LF, 
               array('%i'=>normalize_incidentid(strip_tags($prev['incidentid'])),
               '%u'=>BASEURL.'/incident.php',
               '%I'=>urlencode($prev['incidentid']),
               '%c'=>formatRelativeDate($prev['updated'])));
         }
      }

      // check for grouping within the import queue
      $ip = $element['cache_ip'];
      $group = false;
      if (array_key_exists($ip, $used_ips)) {
         $parent = $used_ips[$ip][0];
         $out .= '  <input type="checkbox" checked value="'.$parent.'" name="group['.$element['id'].']">'.LF;
         $out .=  t(_('  Group with queue item %parent<br/>'), array('%parent'=>$parent)).LF;
         $group = true;
      }
      $used_ips[$ip][] = $element['id'];

      if ($group == false) {
         if (array_key_exists($element['cache_ip'], $openips)) {
            $out .= '  <input type="checkbox" checked name="add['.$id.']">'.LF;
            $out .= t(_('  Add to %id').LF,
            array('%id'=>normalize_incidentid($openips[$element['cache_ip']])));
         }
      }
      $group = false;
      $out .= '  </td>'.LF;
      $out .= '</tr>'.LF;
      $count++;
   }
   $out .= "</table>\n";
   $out .= '<p/>'.LF;
   if ($count == 0) {
      $out .= '<em>'._('No incidents pending.').'</em><p/>';
   }

   /* now, only worry about contact updates
    */
   $newcontacts=0;
   foreach ($elements as $id=>$element) {
      if ($element['metatype'] == AIRT_IMPORTQUEUE_METATYPE_CONTACT) {
         $newcontacts++;
      }
   }
   if ($newcontacts > 0) {
       $out .= '<table class="horizontal">'.LF;
       $out .= '<tr>'.LF;
       $out .= '<th>&nbsp;</th>'.LF;
       $out .= '<th>'._('No.').'</th>'.LF;
       $out .= '<th>'._('Constituency').'</th>'.LF;
       $out .= '</tr>'.LF;
       $count = 0;
       foreach ($elements as $id=>$element) {
          if ($element['metatype'] != AIRT_IMPORTQUEUE_METATYPE_CONTACT) {
             continue;
          }
          $item = queuePeekItem($id, $error);
          if ($item === false) {
             airt_msg(_('Error retrieve queue item in').
                'importqueue.plib'.__LINE__);
             continue;
          }
          $doc = new DOMDocument();
          $doc->loadXML($item['content']);
          $xpath = new DOMXPath($doc);
          $res = $xpath->query('//airt/contactData/constituency');
          $constituency = $res->item(0)->textContent;

          $out .= t('<tr class="%class">', array(
             '%class'=>(($count++ % 2 == 0) ? 'even' : 'odd'))).LF;
          $out .= '   <td>';
          $out .= t('  <input type="checkbox" name="checked[%id]"></td>'.LF,
             array('%id'=>$id));
          $out .= '  <td>'; 
          $out .= t('  <a target="airt_queue" href="%url?action=showdetails&id=%id">%id</a></td>'.LF, array(
             '%url'=>BASEURL.'/importqueue.php',
             '%id'=>$id
          ));
          $out .= '  <td>'.t(_('New contact: %con').'</td>'.LF, array(
             '%con'=>htmlentities($constituency)));
          $out .= '</tr>'.LF;
       }
       $out .= '</table>'.LF;
   }
   $out .= '</div><!-- importqueue-overview-body -->'.LF;
   return $out;
}


/* import queue element into AIRT
 * Parameters
 *   $id - queue element to import
 *   $error - Error message (if any)
 * Returns
 *   0 on success, 1 on failure
 */
function queueToAIRT($id, &$error, $mailtemplate='') {
   global $AIRT_CURL_OPTIONS;
   $saml_ticket = '';
   airt_profile('queueToAIRT: fetching SAML ticket');
   $saml_ticket = getSAMLTicket();
   airt_profile($saml_ticket);
   $saml_ticket = preg_replace('/xmlns:="urn:oasis:names:tc:SAML:1.0:assertion"/','',$saml_ticket);
   $saml_ticket = preg_replace('/xmlns:ds="http:\/\/www.w3.org\/2000\/09\/xmldsig#"/','',$saml_ticket);
   $saml_ticket = preg_replace('/ds:/','',$saml_ticket);
   airt_profile('queueToAIRT: got SAML ticket');
   $doc = new DOMDocument();
   $dom = $doc->loadXML($saml_ticket);
   if ($dom == true) {
      $ticket_element = $doc->getElementsByTagname('KeyValue');
      $ticketid = $ticket_element->item(0)->textContent;
   }

   if(!isset($ticketid) || $ticketid == null) {
      $error = _('Missing key for authentication');
      return 1;
   }

   if ($id == '') {
      $error = _('Missing parameter id');
      return 1;
   }
   $data = queuePeekItem($id, $error);
   if ($data == NULL) {
      return 1;
   }
   $matches = array();
   $name = $email = _('Unknown');
   // Poor man's RFC2822 filter
   if (preg_match('/^([^<]+)<([^>]+)>$/', $data['sender'], $matches) > 0) {
      $name = trim($matches[1]);
      $email = trim($matches[2]);
   }

   // Fetch content from disk and clone root element;
   $doc = new DOMDocument();
   $dom = $doc->loadXML($data['content']);
   
   $airt_client = new SOAP_Client(WS_ENDPOINT);
   $xpath = new DOMXPath($doc);
   if ($xpath->query('//airt/incident')->length > 0) {
      airt_profile('Processing //airt/incident');
      // add mail template information
      $tmp_elements = $doc->getElementsByTagname('technicalInformation');
      if ($tmp_elements->length > 0) {
         $tmp_elements->item(0)->appendChild($doc->createElement('mailtemplate',
            htmlentities($mailtemplate)));
      }
   
      // Create new xml document to pass to web service
      $newdoc = new DOMDocument();
      $airt = $newdoc->appendChild($newdoc->createElement('airt'));
      $ident = $airt->appendChild($newdoc->createElement('messageIdentification'));
      $ticketid = $ident->appendChild($newdoc->createElement('TicketID', $ticketid));
   
      $incident_element = $doc->getElementsByTagName('incident');
      if ($incident_element->length > 0) {
         $data = $incident_element->item(0);
         $airt->appendChild($newdoc->importNode($data, true));
      } else {
         $error = 'Could not find <incident> element';
         return 1;
      }
   
      // Build structure
      $method = 'importIncidentData';
      $params = array('importXML'=>$newdoc->saveXML());

   } elseif ($xpath->query('//airt/contactData')->length > 0) {
# XXX XXX
      airt_profile('Processing //airt/contactData');
      $method = 'importContact';
      $params = array('importXML'=>$data['content']);
   }

   // Call web service

   // process CURL options
   $airt_client->setOpt('timeout', 30);
   foreach ($AIRT_CURL_OPTIONS as $key=>$value) {
      $airt_client->setOpt('curl', $key, $value);
   }
   airt_profile('Calling web service method: '.$method);
   $ans = $airt_client->call($method, $params);
   if (PEAR::isError($ans)) {
      echo "<PRE>";
      echo "SOAP Error:";
      print_r($ans->getFault());
      echo "</PRE>";
      exit;
   }
   return 0;
}


/* Get the random id from the filesystem in order to authenticate, in
 * order to append it to the XML later
 */
function getSAMLTicket() {
   global $AIRT_CURL_OPTIONS;
   airt_profile('getSAMLTicket: start');
   // Build the XML-format for auth-request
   $doc = new DOMDocument();
   $auth = $doc->appendChild($doc->createElement('authentication'));

   $username_el = $doc->createElement('username');
   $username_el->appendChild($doc->createTextNode(WS_USERNAME));
   $auth->appendChild($username_el);

   $password_el = $doc->createElement('password');
   $password_el->appendChild($doc->createTextNode(WS_PASSWORD));
   $auth->appendChild($password_el);

   $xml_auth = $doc->saveXML();
   $airt_client = new SOAP_Client(WS_ENDPOINT);
   $method = 'RequestAuthentication';
   $params = array('auth_request' => $xml_auth);

   // process CURL options
   foreach ($AIRT_CURL_OPTIONS as $key=>$value) {
      $airt_client->setOpt('curl', $key, $value);
   }
   airt_profile('getSAMLTicket: calling web service');
   $ans = $airt_client->call($method, $params);

   if (PEAR::isError($ans)) {
      echo '<pre>';
      echo "SOAP Error:";
      print_r($ans->getFault());
      print '</pre>';
      airt_profile('getSAMLTicket: fail-end');
      exit;
   } else {
      airt_profile('getSAMLTicket: success-end');
      return $ans;
   }
}


/* Add a new element to the queue. This function both inserts into the
 * database and writes to the file system.
 * Parameters:
 *   status  = new queue item status, typically 'open'.
 *   sender  = string with queue item sender.
 *   type    = string with queue item type.
 *   summary = string with queue item summary.
 *   content = formatted string with XML item content.
 *   filter  = name of the filter used to import the queue element.
 *   version = version number of the filter
 *   error   = variable to write the error string to, if any.
 * All parameters are passed on to the database without any change except
 * for trimming leading and trailing white space. Empty strings (after
 * trimming white space) are not allowed.
 * Returns:
 *   The queue ID of the newly added item, or FALSE in case of failure.
 *   If FALSE, the error parameter will contain an error message.
 */
function queueInsertItem($data, &$error) {
   global $AIRT_IMPORTQUEUE_METATYPES;

   // Superficial sanity check of the parameters.
   if (array_key_exists('status', $data)) {
      $status  = trim(db_escape_string($data['status']));
   } else {
      $error = _('Missing parameter status in').
         ' importqueue.plib:'.__LINE__;
      return false;
   }
   if (array_key_exists('sender', $data)) {
      $sender  = trim(db_escape_string($data['sender']));
   } else {
      $error = _('Missing parameter sender in').
         ' importqueue.plib:'.__LINE__;
      return false;
   }
   if (array_key_exists('type', $data)) {
      $type    = trim(db_escape_string($data['type']));
   } else {
      $error = _('Missing parameter type in').
         ' importqueue.plib:'.__LINE__;
      return false;
   }
   if (array_key_exists('summary', $data)) {
      $summary = trim(db_escape_string($data['summary']));
      if (strlen($summary) > 100) {
         $summary = substr($summary, 0, 100);
      }
   } else {
      $error = _('Missing parameter summary in').
         ' importqueue.plib:'.__LINE__;
      return false;
   }
   if (array_key_exists('content', $data)) {
      $content = trim(db_escape_string($data['content']));
   } else {
      $error = _('Missing parameter content in').
         ' importqueue.plib:'.__LINE__;
      return false;
   }
   if (array_key_exists('filter', $data)) {
      $filter  = trim(db_escape_string($data['filter']));
   } else {
      $error = _('Missing parameter filter in').
         ' importqueue.plib:'.__LINE__;
      return false;
   }
   if (array_key_exists('version', $data)) {
      $version  = trim(db_escape_string($data['version']));
   } else {
      $error = _('Missing parameter version in').
         ' importqueue.plib:'.__LINE__;
      return false;
   }
   if (array_key_exists('metatype', $data)) {
      $metatype = trim(db_escape_string($data['metatype']));
      if (!in_array($metatype, $AIRT_IMPORTQUEUE_METATYPES)) {
         $error = _('Invalid import queue meta type in').
            ' importqueue.plib:'.__LINE__;
         return false;
      }
   } else {
      $metatype = AIRT_IMPORTQUEUE_METATYPE_INCIDENT;
   }

   $cache_ip = $cache_constituency = $cache_mailtemplate = '';

   // Fetch a fresh queue item ID from the database.
   $q = "select nextval('importqueue_sequence') as id";
   $res = db_query($q);
   if (!$res) {
      $error = _('Cannot get next queue item ID');
      return FALSE;
   }
   $row = db_fetch_next($res);
   $newID = sprintf('%08d',$row['id']);

   $dom = new DOMDocument();
   if ($dom->loadXML($content)) {
      $el = $dom->getElementsByTagname('ip');
      if ($el->length > 0) {
         $cache_ip = $el->item(0)->textContent;
         $networkid = categorize($cache_ip);
         $consid = getConstituencyIDByNetworkID($networkid);
         $conslist = getConstituencies();
         $cache_constituency = $conslist[$consid]['label'];
      }
      if (getPreferredMailtemplate($filter, $version, $cache_mailtemplate,
         $error) > 0) {
         return false;
      }
   }

   $cache_ip = trim(db_escape_string($cache_ip));
   $cache_constituency = trim(db_escape_string($cache_constituency));
   $cache_mailtemplate = trim(db_escape_string($cache_mailtemplate));

   // Insert the record. Strings have already been escaped.
   $q = "INSERT INTO import_queue
           (id,created,status,sender,type,summary,content, cache_ip,
            cache_constituency, cache_mailtemplate, filter, version,
            metatype)
         VALUES
           ($newID,CURRENT_TIMESTAMP,'open','$sender','$type',
            '$summary','$content','$cache_ip', '$cache_constituency',
            '$cache_mailtemplate', '$filter', '$version', '$metatype')";
   if (!db_query($q)) {
      $error = _('Could not insert new queue item');
      return FALSE;
   }
   return $newID;
}// queueInsertItem



/* Retrieve an element from the queue. The element is not touched, to remove
 * it from the queue it needs to be queueRemove()d.
 * Parameters:
 *   id    = The queue item ID to be retrieved.
 *   error = variable to write the error string to, if any.
 * Returns:
 *   An array with all fields of the queue item, indexed 'status', 'sender',
 *   'type', 'summary', and 'content'. In case of retrieval failure, FALSE.
 */
function queuePeekItem($id,&$error) {
   $res = db_query(q('SELECT status, sender, type, summary, content,
      cache_ip, cache_constituency
      FROM import_queue
      WHERE id=%id', array('%id'=>$id)));
   if ($res == false) {
      $error = _('Unable to query database').' in importqueue.plib:'.__LINE__;
      return false;
   }
   if (db_num_rows($res) == 0) {
      $error = _('Request for invalid queue item');
      return false;
   }
   $out = db_fetch_next($res);

   db_free_result($res);
   return $out;
}// queuePeekItem


/* Remove an element from the queue. This function both deleted from the
 * database and deletes from the file system.
 * Parameters:
 *   id    = The queue item ID to be removed.
 *   error = variable to write the error string to, if any.
 * Returns:
 *   0 in case of successful removal, 1 in case of a problem.
 */
function queueRemoveItem($id,&$error) {
   $error = _('Not yet implemented');
   return 1;
}// queueRemoveItem

/* Add logging contained in a queue element to an AIRT incident.
 * 
 * Parameters
 *   id (integer) = The queue item ID to be processed
 *   error (string) = variable to write the error string to, if any.
 * Returns
 *   0 in case of success, 1 in case of failure
 */
function queueAddLogging($id, &$error, $template='', &$incidentid) {
   global $AIRT_CURL_OPTIONS;

   if (fetchAuthticket($ticket, $error) != 0) {
      return 1;
   }

   // fetch item from queue
   $item = queuePeekItem($id, $error);
   if (!$item) {
      return 2;
   }

   // fetch open incidents 
   $openips = array();
   foreach (getOpenincidents() as $id=>$data) {
      $openips[$data['ip']] = $id;
   }
   if (!array_key_exists($item['cache_ip'], $openips)) {
      $error = _('Invalid cache data');
      return 3;
   }

   // fetch logging from item
   $dom = new DOMDocument();
   $dom->loadXML($item['content']);

   $logging_els = $dom->getElementsByTagname('logging');
   if ($logging_els->length == 0) {
      $error = _('Invalid XML (no logging)');
      return 4;
   }
   $logging = '';
   foreach ($logging_els as $log_el) {
      $logging .= $log_el->textContent;
   }

   // Call web service
   $airt_client = new SOAP_Client(WS_ENDPOINT);
   $method = "addLogging";
   $incidentid = $openips[$item['cache_ip']];
   $params = array(
      'incidentid'=>$incidentid,
      'logging'=>$logging,
      'template'=>$template,
      'authticket'=>$ticket);

   // process CURL options
   foreach ($AIRT_CURL_OPTIONS as $key=>$value) {
      $airt_client->setOpt('curl', $key, $value);
   }
   $ans = $airt_client->call($method, $params);
   if (PEAR::isError($ans)) {
      $error = 'SOAP Error';
      return 5;
   }
   addIncidentComment(array(
      'comment'=>_('Logging added to incident from import queue'),
      'incidentid'=>$params['incidentid']));
   if (defined('WS_IMPORT_RESETSTATE') && WS_IMPORT_RESETSTATE === true) {
      $state = array_search(WS_IMPORT_DEFAULTSTATE, getIncidentStates());
      if ($state == false) {
         $state = getIncidentStateDefault();
      }
      updateIncident($params['incidentid'], array('state'=>$state));
      addIncidentComment(array(
         'comment'=>t(_('State reset to %state.'),
            array('%state'=>getIncidentStateLabelByID($state))),
         'incidentid'=>$params['incidentid']));
   }
   return 0;
}


/* Fetch an authentication ticket from the web service
 *
 * Parameters:
 *    ticket (string); variable to write the ticket to, if sucessfully retrieved
 *    error (string); variable to write error message in, if any
 * Returns
 *    0 on success, 1 in case of a problem
 */
function fetchAuthTicket(&$ticket, &$error) {
   global $AIRT_CURL_OPTIONS;
   $saml_ticket = '';
   $saml_ticket = getSAMLTicket();
   $saml_ticket = preg_replace('/xmlns:="urn:oasis:names:tc:SAML:1.0:assertion"/','',$saml_ticket);
   $saml_ticket = preg_replace('/xmlns:ds="http:\/\/www.w3.org\/2000\/09\/xmldsig#"/','',$saml_ticket);
   $saml_ticket = preg_replace('/ds:/','',$saml_ticket);
   $doc = new DOMDocument();
   $dom = $doc->loadXML($saml_ticket);
   if($dom == true) {
      $ticket_element = $doc->getElementsByTagname('KeyValue');
      $ticket = $ticket_element->item(0)->textContent;
   }
   if(!isset($ticket) || $ticket == null) {
      $error = _('Missing key for authentication');
      return 1;
   } else {
      return 0;
   }
}

/** Accept import queue element into AIRT.
 * @param $id ID of import queue element.
 * @param $template mailtemplate to associate with queue submission
 * Function will redirect browser. Should be done prettier some day.
 */
function queueElementAccept($id, $template='') {
   $value = 'accepted';
   $update = true;
   print t(_('Accepting queue element %id<br/>').LF, array('%id'=>$id));
   flush();
   if (isset($_POST['add'][$id]) && $_POST['add'][$id] == 'on') {
      $error = '';
      $incidentid = _('Unknown');
      if (queueAddLogging($id, $error, $template, $incidentid)) {
         print t(_('Error processing item: %error'), array(
            '%error'=>$error));
         $update = false;
      } else {
         $update = true;
      }
      print '  '.t(_('Adding to existing incident %s<br/>').LF, 
         array('%s'=>normalize_incidentid($incidentid)));
   } else if (queueToAIRT($id, $error, $template)) {
      $update = false;
      airt_error('ERR_FUNC', 'importqueue.plib:'.__LINE__, $error);
      return;
   }
   if ($update) {
      if (updateQueueItem($id, 'status', $value, $error)) {
         airt_error('ERR_QUERY', 'importqueue.plib:'.__LINE__, $error);
         Header("Location: $_SERVER[PHP_SELF]");
         return;
      }
   }
} // queueElementAccept

/** Normalize the import queue by grouping all queue items that are tagged to belong together.
 * Parameters
 *   @param $group array of grouping operators
 *   @param $checked array of checked elements
 *   @param $decision operator to be applied
 * Return
 *   Normalized list of queue elements
 */
function queueNormalize($group, $checked, $decision) {
   $output = $checked;
   foreach ($group as $sibling_id=>$parent_id) {
      if (array_key_exists($sibling_id, $checked) && $checked[$sibling_id] == 'on' &&
          $decision == 'accept') {
         print t(_('Merging %sibling into %parent').'<br/>'.LF, array(
            '%sibling'=>$sibling_id, '%parent'=>$parent_id));

         // we will only update the logging; IP addresses will be identical and AIRT does not 
         // do anything with the time of the incident yet.

         // 1. Fetch logging of sibling
         $sibling_item = queuePeekItem($sibling_id, $error);
         $sibling_dom = new DOMDocument();
         if ($sibling_dom->loadXML($sibling_item['content']) == false) {
            $error = _('Unable to parse xml in sibling content');
         } else {
            $sibling_logging_elements = $sibling_dom->getElementsByTagname('logging');
         }

         // 2. Fetch logging of parent
         $parent_item = queuePeekItem($parent_id, $error);
         $parent_dom = new DOMDocument();
         if ($parent_dom->loadXML($parent_item['content']) == false) {
            $error = _('Unable to parse xml in parent content');
         } else {
            $parent_logging_elements = $parent_dom->getElementsByTagname('logging');
            $old_element = $parent_logging_elements->item(0);
            $new_element = $parent_dom->createElement('logging',
               $parent_logging_elements->item(0)->textContent.LF.
               $sibling_logging_elements->item(0)->textContent);
            $old_element->parentNode->replaceChild($new_element, $old_element);

            if (updateQueueItem($parent_id, 'content', $parent_dom->saveXML(), $error)) {
               airt_error('ERR_QUERY', 'importqueue.plib:'.__LINE__, $error);
               Header("Location: $_SERVER[PHP_SELF]");
               return;
            } else {
               unset($output[$sibling_id]);
               // unset sibling's new status
               if (updateQueueItem($sibling_id, 'status', 'merged', $error)) {
                  airt_error('ERR_QUERY', 'importqueue.plib:'.__LINE__, $error);
                  Header("Location: $_SERVER[PHP_SELF]");
                  return;
               }
            }
         }
      }
   }
   return $output;
}

/** Set preferred mail template for import filter
 * @param $error Contains error message when failure
 * Returns 0 on success, 1 on failure. 
 */
function setPreferredMailtemplate($filter, $version='', $template, &$error) {
   $error = '';
   $update = true;
   $cur_template = '';

   if (empty($filter) || empty($template)) {
      $error = 'Missing parameter';
      return 1;
   }

   if (getPreferredMailtemplate($filter, $version, $cur_template, $errror) > 0) {
      return 1;
   }

   if (empty($cur_template)) {
      $update = false;
   }
   if ($cur_template == $template) {
      // nothing to do
      return 0;
   }

   if ($update) {
      $q = q("UPDATE importqueue_templates
              SET    mailtemplate='%templ'
              WHERE  filter='%filter'
              AND    version='%version'", array(
                 '%templ'=>db_escape_string($template),
                 '%filter'=>db_escape_string($filter),
                 '%version'=>db_escape_string($version)));
   } else {
      $q = q("INSERT INTO importqueue_templates
              (id, filter, version, mailtemplate)
              VALUES
              (nextval('importqueue_templates_sequence'),
              '%filter', '%version', '%templ')", array(
                 '%templ'=>db_escape_string($template),
                 '%filter'=>db_escape_string($filter),
                 '%version'=>db_escape_string($version)));
   }
   $res = db_query($q);
   if ($res == false) {
      $error = 'Database error in importqueue.plib:'.__LINE__;
      return 1;
   }
   return 0;
} //setPreferredMailtemplate

/** Fetch the preferred mail template for a specific filter's version.
 * @param $error Will contain an error message, if any
 * @return 0 on success, 1 on failure
 */
function getPreferredMailtemplate($filter, $version, &$template, &$error) {
   $error = '';
   $template = '';

   if (empty($filter) || empty($version)) {
      $error .= 'Missing parameter in importqueue.plib:'.__LINE__;
      return 1;
   }

   $q = q("SELECT mailtemplate
           FROM   importqueue_templates
           WHERE  filter='%filter'
           AND    version='%version'", array(
              '%filter'=>db_escape_string($filter),
              '%version'=>db_escape_string($version)));
   $res = db_query($q);
   if ($res == false) {
      $error = 'Database error in importqueue.plib:'.__LINE;
      return 1;
   }
   if (db_num_rows($res) > 0) {
      $row = db_fetch_next($res);
      $template = $row['mailtemplate'];
   }
   return 0;
} // getPreferredMailtemplate


/** Fetch the preferred mail template for a specific filter's version.
 * @param $error Will contain an error message, if any
 * @return 0 on success, 1 on failure
 */
function removePreferredMailtemplate($filter, $version, &$error) {
   $error = '';
   $cur_template = '';

   if (empty($filter)) {
      $error = 'Missing parameter in importqueue.plib:'.__LINE__;
      return 1;
   }
   if (getPreferredMailtemplate($filter, $version, $cur_template, $errror) > 0) {
      return 1;
   }
   if (empty($cur_template)) {
      // nothing to do.
      return 0;
   }
   $q = q("DELETE FROM importqueue_templates
           WHERE  filter='%filter'
           AND    version='%version'", array(
              '%filter'=>db_escape_string($filter),
              '%version'=>db_escape_string($version)));
   $res = db_query($q);
   if ($res == false) {
      $error = 'Database error in importqueue.plib:'.__LINE;
      return 1;
   }
   return 0;
} // removePreferredMailtemplate


/** Retrieve a list of preferred mail templates
 * @param $items associative array with items
 * @param $error error msg, if any
 * @return 0 on success, 1 on failure
 */
function importqueueTemplatesGetItems(&$items, &$error) {
   $items = array();
   $error = '';
   $res = db_query(q("SELECT id, filter, version, mailtemplate
      FROM importqueue_templates
      ORDER BY filter, version"));
   if ($res == false) {
      $error = 'Error querying database in importqueue.plib'.__LINE__;
      return 1;
   }
   while ($row = db_fetch_next($res)) {
      $items[$row['id']] = $row;
   }
   return 0;
}


/** Return a formatted list of preferred mail templates
 */
function importqueueTemplatesFormatItems() {
   if (importqueueTemplatesGetItems($items, $error) > 0) {
      return "ERROR: ".$error;
   }
   $out = '<form method="GET">'.LF;
   $out .= '<div class="importqueue-preftempl-list">'.LF;
   $out .= '<table class="horizontal">'.LF;
   $out .= '<tr>'.LF;
   $out .= '  <th>&nbsp;</th>'.LF;
   $out .= '  <th>'._('Filter').'</th>'.LF;
   $out .= '  <th>'._('Version').'</th>'.LF;
   $out .= '  <th>'._('Template').'</th>'.LF;
   $out .- '</tr>'.LF;
   $count = 0;
   foreach ($items as $id=>$item) {
      $out .= '<tr>'.LF;
      $out .= '<td><input type="checkbox" name="check['.
         strip_tags($id).']"></td>'.LF;
      $out .= t('<td>%filter</td>'.LF,
         array('%filter'=>strip_tags($item['filter'])));
      $out .= t('<td>%version</td>'.LF,
         array('%version'=>strip_tags($item['version'])));
      $out .= t('<td>%template</td>'.LF,
         array('%template'=>strip_tags($item['mailtemplate'])));
      $out .= '</tr>';
   }
   $out .= '</table>';
   if ($count == 0) {
      $out .= '<p/><I>'._('No preferred mail templates defined.').'</I>'.LF;
   }
   $out .= '</div>';
   $out .= '<p/>'.LF;
   $out .= '<div class="importqueue-preftempl-add">'.LF;
   $out .= '<table class="horizontal">'.LF;
   $out .= '<tr>'.LF;
   $out .= '<td>Filter name:</td>'.LF;
   $out .= '<td><input type="text" name="filter" size="30">'.LF;
   $out .= t('<a onClick="window.open(\'%url?action=list_filters\', \''.
      _('Available import filters').'\',
      \'width=600,height=400\')" 
      href="">'._('Available filters').'</a></td>',
      array('%url'=>$_SERVER['PHP_SELF'])).LF;
   $out .= '</tr>'.LF;
   $out .= '<tr>'.LF;
   $out .= '<td>Filter version:</td>'.LF;
   $out .= '<td><input type="text" name="version" size="30"></td>'.LF;
   $out .= '</tr>'.LF;
   $out .= '<tr>'.LF;
   $out .= '<td>Mail template:</td>'.LF;
   $out .= '<td>'.LF;
   $out .= getMailtemplateSelection('mailtemplate');
   $out .= '</td>'.LF;
   $out .= '</tr>'.LF;
   $out .= '</table>'.LF;
   $out .= '<input type="submit" name="action" value="'.
           _('Add preferred template').'">'.LF;
   $out .= '<input type="submit" name="action" value="'.
           _('Remove checked preferred templates').'">'.LF;
   $out .= '</div>';
   $out .= '</form>';

   return $out;
}
?>
